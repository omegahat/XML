
R Under development (unstable) (2011-11-27 r57757)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-apple-darwin11.0.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "XML"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('XML')
> 
> assign(".oldSearch", search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AssignXMLNode")
> ### * AssignXMLNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: [<-.XMLNode
> ### Title: Assign sub-nodes to an XML node
> ### Aliases: [<-.XMLNode [[<-.XMLNode
> ### Keywords: IO file
> 
> ### ** Examples
> 
>  top <- xmlNode("top", xmlNode("next","Some text"))
>  top[["second"]] <- xmlCDataNode("x <- 1:10")
>  top[[3]] <- xmlNode("tag",attrs=c(id="name"))
> 
> 
> 
> cleanEx()
> nameEx("Doctype-class")
> ### * Doctype-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Doctype-class
> ### Title: Class to describe a reference to an XML DTD
> ### Aliases: Doctype-class
> ### Keywords: classes
> 
> ### ** Examples
> 
>   d = Doctype(name = "section", public = c("-//OASIS//DTD DocBook XML V4.2//EN", "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd"))  
> 
> 
> 
> cleanEx()
> nameEx("Doctype")
> ### * Doctype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Doctype
> ### Title: Constructor for DTD reference
> ### Aliases: Doctype coerce,Doctype,character-method
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
>   d = Doctype(name = "section", public = c("-//OASIS//DTD DocBook XML V4.2//EN", "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd"))
>   as(d, "character")
[1] "<!DOCTYPE section PUBLIC \"-//OASIS//DTD DocBook XML V4.2//EN\" \"http://oasis-open.org/docbook/xml/4.2/docbookx.dtd\" >"
> 
>    # this call switches the system to the URI associated with the PUBLIC element.
>   d = Doctype(name = "section", public = c("-//OASIS//DTD DocBook XML V4.2//EN"), system = "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd")
> 
> 
> 
> cleanEx()
> nameEx("SAXState-class")
> ### * SAXState-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SAXState-class
> ### Title: A virtual base class defining methods for SAX parsing
> ### Aliases: SAXState-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> 
> # For each element in the document, grab the node name
> # and increment the count in an vector for this name.
> 
> # We define an S4 class named ElementNameCounter which
> # holds the vector of frequency counts for the node names.
> 
>  setClass("ElementNameCounter",
+              representation(elements = "integer"), contains = "SAXState")
[1] "ElementNameCounter"
> 
> # Define a method for handling the opening/start of any XML node
> # in the SAX streams.
> 
>  setMethod("startElement.SAX",  c(.state = "ElementNameCounter"),
+            function(name, atts, .state = NULL) {
+ 
+              if(name %in% names(.state@elements))
+                  .state@elements[name] = as.integer(.state@elements[name] + 1)
+              else
+                  .state@elements[name] = as.integer(1)
+              .state
+            })
[1] "startElement.SAX"
> 
>  filename = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML")
> 
> # Parse the file, arranging to have our startElement.SAX method invoked.
>  z = xmlEventParse(filename, genericSAXHandlers(), state = new("ElementNameCounter"), addContext = FALSE)
> 
>  z@elements
gesmes:Envelope  gesmes:subject   gesmes:Sender     gesmes:name            Cube 
              1               1               1               1           60086 
> 
>   # Get the contents of all the comments in a character vector.
> 
>  setClass("MySAXState",
+              representation(comments = "character"), contains = "SAXState")
[1] "MySAXState"
> 
>  setMethod("comment.SAX",  c(.state = "MySAXState"),
+            function(content, .state = NULL) {
+              cat("comment.SAX called for MySAXState\n")
+              .state@comments <- c(.state@comments, content)
+              .state
+            })
[1] "comment.SAX"
> 
>  filename = system.file("exampleData", "charts.svg", package = "XML")
>  st = new("MySAXState")
>  z = xmlEventParse(filename, genericSAXHandlers(useDotNames = TRUE), state = st)
comment.SAX called for MySAXState
>  z@comments
[1] " generated by Grace-5.1.0 "
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("XMLInternalDocument")
> ### * XMLInternalDocument
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: XMLInternalDocument-class
> ### Title: Class to represent reference to C-level data structure for an
> ###   XML document
> ### Aliases: XMLAbstractDocument-class XMLInternalDocument-class
> ###   HTMLInternalDocument-class
> ###   coerce,XMLInternalNode,XMLInternalDocument-method
> ###   coerce,XMLInternalDocument,XMLInternalNode-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> 
>  f = system.file("exampleData", "mtcars.xml", package="XML")
>  doc = xmlParse(f)
>  getNodeSet(doc, "//variables[@count]")
[[1]]
<variables count="11">
  <variable unit="Miles/gallon">mpg</variable>
  <variable>cyl</variable>
  <variable>disp</variable>
  <variable>hp</variable>
  <variable>drat</variable>
  <variable>wt</variable>
  <variable>qsec</variable>
  <variable>vs</variable>
  <variable type="FactorVariable" levels="automatic,manual">am</variable>
  <variable>gear</variable>
  <variable>carb</variable>
</variables> 

attr(,"class")
[1] "XMLNodeSet"
>  getNodeSet(doc, "//record")
[[1]]
<record id="Mazda RX4">   21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</record> 

[[2]]
<record id="Mazda RX4 Wag"> 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4</record> 

[[3]]
<record id="Datsun 710">  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</record> 

[[4]]
<record id="Hornet 4 Drive">      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1</record> 

[[5]]
<record id="Hornet Sportabout">   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</record> 

[[6]]
<record id="Valiant">             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1</record> 

[[7]]
<record id="Duster 360">          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</record> 

[[8]]
<record id="Merc 240D">           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</record> 

[[9]]
<record id="Merc 230">            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2</record> 

[[10]]
<record id="Merc 280">            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</record> 

[[11]]
<record id="Merc 280C">           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4</record> 

[[12]]
<record id="Merc 450SE">          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</record> 

[[13]]
<record id="Merc 450SL">          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</record> 

[[14]]
<record id="Merc 450SLC">         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</record> 

[[15]]
<record id="Cadillac Fleetwood">  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</record> 

[[16]]
<record id="Lincoln Continental"> 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</record> 

[[17]]
<record id="Chrysler Imperial">   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</record> 

[[18]]
<record id="Fiat 128">            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</record> 

[[19]]
<record id="Honda Civic">         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</record> 

[[20]]
<record id="Toyota Corolla">      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</record> 

[[21]]
<record id="Toyota Corona">       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1</record> 

[[22]]
<record id="Dodge Challenger">    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2</record> 

[[23]]
<record id="AMC Javelin">         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2</record> 

[[24]]
<record id="Camaro Z28">          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</record> 

[[25]]
<record id="Pontiac Firebird">    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</record> 

[[26]]
<record id="Fiat X1-9">           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</record> 

[[27]]
<record id="Porsche 914-2">       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</record> 

[[28]]
<record id="Lotus Europa">        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</record> 

[[29]]
<record id="Ford Pantera L">      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</record> 

[[30]]
<record id="Ferrari Dino">        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</record> 

[[31]]
<record id="Maserati Bora">       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</record> 

[[32]]
<record id="Volvo 142E">          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</record> 

attr(,"class")
[1] "XMLNodeSet"
> 
>  getNodeSet(doc, "//record[@id='Mazda RX4']")
[[1]]
<record id="Mazda RX4">   21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</record> 

attr(,"class")
[1] "XMLNodeSet"
> 
>  # free(doc)
> 
> 
> 
> cleanEx()
> nameEx("XMLNode-class")
> ### * XMLNode-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: XMLNode-class
> ### Title: Classes to describe an XML node object.
> ### Aliases: XMLAbstractNode-class XMLAbstractNode-class RXMLNode-class
> ###   XMLNode-class XMLTreeNode-class XMLInternalNode-class
> ###   XMLInternalTextNode-class XMLInternalElementNode-class
> ###   XMLInternalCommentNode-class XMLInternalPINode-class
> ###   XMLInternalCDataNode-class XMLAttributeDeclNode-class
> ###   XMLDocumentFragNode-class XMLDocumentNode-class
> ###   XMLDocumentTypeNode-class XMLEntityDeclNode-class
> ###   XMLNamespaceDeclNode-class XMLXIncludeStartNode-class
> ###   XMLXIncludeEndNode-class XMLDTDNode-class
> ###   coerce,XMLAbstractNode,Date-method
> ###   coerce,XMLAbstractNode,POSIXct-method
> ###   coerce,XMLAbstractNode,URL-method
> ###   coerce,XMLAbstractNode,character-method
> ###   coerce,XMLAbstractNode,integer-method
> ###   coerce,XMLAbstractNode,logical-method
> ###   coerce,XMLAbstractNode,numeric-method XMLNamespaceDefinitions-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> 
>            # An R-level XMLNode object
>    a <- xmlNode("arg", attrs = c(default="T"),
+                  xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))
> 
>   xmlAttrs(a) = c(a = 1, b = "a string")
> 
> 
> 
> cleanEx()
> nameEx("addChildren")
> ### * addChildren
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addChildren
> ### Title: Add child nodes to an XML node
> ### Aliases: addChildren xmlParent<- removeChildren removeNodes
> ###   removeNodes.list removeNodes.XMLNodeSet removeNodes.XMLInternalNode
> ###   replaceNodes addAttributes removeAttributes
> ###   addChildren,XMLInternalNode-method addChildren,XMLNode-method
> ###   addAttributes,XMLInternalElementNode-method
> ###   addAttributes,XMLNode-method
> ###   removeAttributes,XMLInternalElementNode-method
> ###   removeAttributes,XMLNode-method
> ### Keywords: IO programming
> 
> ### ** Examples
> 
> 
> b = newXMLNode("bob", namespace = c(r = "http://www.r-project.org", omg = "http://www.omegahat.org"))
> 
> cat(saveXML(b), "\n")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org"/> 
> 
> addAttributes(b, a = 1, b = "xyz", "r:version" = "2.4.1", "omg:len" = 3)
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" a="1" b="xyz" r:version="2.4.1" omg:len="3"/> 
> cat(saveXML(b), "\n")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" a="1" b="xyz" r:version="2.4.1" omg:len="3"/> 
> 
> removeAttributes(b, "a", "r:version")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" a="1" b="xyz" omg:len="3"/> 
> cat(saveXML(b), "\n")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" a="1" b="xyz" omg:len="3"/> 
> 
> 
> removeAttributes(b, .attrs = names(xmlAttrs(b)))
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3"/> 
> 
> 
> addChildren(b, newXMLNode("el", "Red", "Blue", "Green",
+                            attrs = c(lang ="en")))
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
</bob> 
> 
> k = lapply(letters, newXMLNode)
> addChildren(b, kids = k)
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <a/>
  <b/>
  <c/>
  <d/>
  <e/>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <m/>
  <n/>
  <o/>
  <p/>
  <q/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
  <z/>
</bob> 
> 
> cat(saveXML(b), "\n")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <a/>
  <b/>
  <c/>
  <d/>
  <e/>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <m/>
  <n/>
  <o/>
  <p/>
  <q/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
  <z/>
</bob> 
> 
> removeChildren(b, "a", "b", "c", "z")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <d/>
  <e/>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <m/>
  <n/>
  <o/>
  <p/>
  <q/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
</bob> 
> 
>   # can mix numbers and names
> removeChildren(b, 2, "e")  # d and e
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <m/>
  <n/>
  <o/>
  <p/>
  <q/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
</bob> 
> 
> cat(saveXML(b), "\n")
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <m/>
  <n/>
  <o/>
  <p/>
  <q/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
</bob> 
> 
> 
> i = xmlChildren(b)[[5]]
> xmlName(i)
[1] "i"
> 
>  # have the identifiers
> removeChildren(b, kids = c("m", "n", "q"))
<bob xmlns:r="http://www.r-project.org" xmlns:omg="http://www.omegahat.org" omg:len="3">
  <el lang="en">RedBlueGreen</el>
  <f/>
  <g/>
  <h/>
  <i/>
  <j/>
  <k/>
  <l/>
  <o/>
  <p/>
  <r/>
  <s/>
  <t/>
  <u/>
  <v/>
  <w/>
  <x/>
  <y/>
</bob> 
> 
> 
> 
> x <- xmlNode("a", 
+                xmlNode("b", "1"),
+                xmlNode("c", "1"),
+ 	       "some basic text")
> 
> v = removeChildren(x, "b")
> 
>   # remove c and b
> v = removeChildren(x, "c", "b")
> 
>   # remove the text and "c" leaving just b
> v = removeChildren(x, 3, "c")
> 
> ## Not run: 
> ##D     # this won't work as the 10 gets coerced to a 
> ##D     # character vector element to be combined with 'w'
> ##D     # and there is no node name 10.
> ##D  removeChildren(b, kids = c(10, "w"))
> ## End(Not run)
> 
> 
>  # for R-level nodes (not internal)
> 
> z = xmlNode("arg", attrs = c(default="TRUE"),
+               xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))
> 
> o = addChildren(z,
+                 "some text",
+                 xmlNode("a", "a link", attrs = c(href = "http://www.omegahat.org/RSXML")))
> o
<arg default="TRUE">
 <name>foo</name>
 <defaultValue>1:10</defaultValue>
 some text
 <a href="http://www.omegahat.org/RSXML">a link</a>
</arg>
> 
> 
>   # removing nodes
> 
>  doc = xmlParse("<top><a/><b/><c><d/><e>bob</e></c></top>")
>  top = xmlRoot(doc)
>  top
<top>
  <a/>
  <b/>
  <c>
    <d/>
    <e>bob</e>
  </c>
</top> 
>  
>  removeNodes(list(top[[1]], top[[3]]))
NULL
> 
>     # a and c have disappeared.
>  top
<top>
  <b/>
</top> 
> 
> 
> 
> 
> cleanEx()
> nameEx("addNode")
> ### * addNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addNode
> ### Title: Add a node to a tree
> ### Aliases: addNode addNode.XMLHashTree
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
>   tt = xmlHashTree()
> 
>   top = addNode(xmlNode("top"), character(), tt)
>   addNode(xmlNode("a"), top, tt)
<a/>
>   b = addNode(xmlNode("b"), top, tt)
>   c = addNode(xmlNode("c"), b, tt)
>   addNode(xmlNode("c"), top, tt)
<c/>
>   addNode(xmlNode("c"), b, tt)    
<c/>
>   addNode(xmlTextNode("Some text"), c, tt)
Some text
> 
>   xmlElementsByTagName(tt$top, "c")
$c
<c/>

> 
>   tt
<top>
 <a/>
 <b>
  <c>Some text</c>
  <c/>
 </b>
 <c/>
</top>
> 
> 
> 
> cleanEx()
> nameEx("addSibling")
> ### * addSibling
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getSibling
> ### Title: Manipulate sibling XML nodes
> ### Aliases: getSibling addSibling
> ### Keywords: IO
> 
> ### ** Examples
> 
>   
>           # Reading Apple's iTunes files
>      # 
>      #           Here we read  a "censored" "database" of songs from Apple's  iTune application
>      #           which is stored in a property list.  The format is quite generic and 
>      #            the fields for each song are given in the form
>      #           
>      #             <key>Artist</key><string>Person's name</string>
>      # 	  
>      #           So to find the names of the artists for all the songs, we want to 
>      #           find all the <key>Artist<key> nodes and then get their next sibling
>      #           which has the actual value.
>      #         
>      #           More information can be found in .
>      # 	
>            fileName = system.file("exampleData", "iTunes.plist", package = "XML")
> 
>            doc = xmlParse(fileName)
>            nodes = getNodeSet(doc, "//key[text() = 'Artist']")
>            sapply(nodes, function(x)  xmlValue(getSibling(x)))
[1] "Norah Jones" "Norah Jones"
> 	
> 
>       f = system.file("exampleData", "simple.xml", package = "XML")
>       tt = as(xmlParse(f), "XMLHashTree") 
> 
>        tt
<a>
 <b foo="bar">
  <c>
   <x>Some text</x>
  </c>
  <d/>
 </b>
 <e>
  <f>
   <g/>
  </f>
 </e>
</a>
> 
>       e = getSibling(xmlRoot(tt)[[1]])
>         # and back to the first one again by going backwards along the sibling list.
>       getSibling(e, after = FALSE)
<b foo="bar">
 <c>
  <x>Some text</x>
 </c>
 <d/>
</b>
> 
> 
>          # This also works for multiple top-level "root" nodes
>       f = system.file("exampleData", "job.xml", package = "XML")
>       tt = as(xmlParse(f), "XMLHashTree")
>        x = xmlRoot(tt, skip = FALSE)
>        getSibling(x)
<!-- Initial Comment -->
>        getSibling(getSibling(x), after = FALSE)
<gjob:Helping xmlns:gjob="http://www.gnome.org/some-location">
 <gjob:Jobs>
  <gjob:Job>
   <gjob:Project ID="3"/>
   <gjob:Application>GBackup</gjob:Application>
   <gjob:Category>Development</gjob:Category>
   <gjob:Update>
    <gjob:Status>Open</gjob:Status>
    <gjob:Modified>Mon, 07 Jun 1999 20:27:45 -0400 MET DST</gjob:Modified>
    <gjob:Salary>USD 0.00</gjob:Salary>
   </gjob:Update>
   <gjob:Developers>
    <gjob:Developer>
        </gjob:Developer>
   </gjob:Developers>
   <gjob:Contact>
    <gjob:Person>Nathan Clemons</gjob:Person>
    <gjob:Email>nathan@windsofstorm.net</gjob:Email>
    <gjob:Company>
        </gjob:Company>
    <gjob:Organisation>
        </gjob:Organisation>
    <gjob:Webpage>
        </gjob:Webpage>
    <gjob:Snailmail>
        </gjob:Snailmail>
    <gjob:Phone>
        </gjob:Phone>
   </gjob:Contact>
   <gjob:Requirements>
      The program should be released as free software, under the GPL.
      </gjob:Requirements>
  </gjob:Job>
 </gjob:Jobs>
</gjob:Helping>
> 
> 
> 
> cleanEx()
> nameEx("append.XMLNode")
> ### * append.XMLNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append.xmlNode
> ### Title: Add children to an XML node
> ### Aliases: append.xmlNode append.XMLNode
> ### Keywords: file IO
> 
> ### ** Examples
> 
>   # Create a very simple representation of a simple dataset.
>   # This is just an example. The result is
>    # <data numVars="2" numRecords="3">
>    # <varNames>
>    #  <string>
>    #   A
>    #  </string>
>    #  <string>
>    #   B
>    #  </string>
>    # </varNames>
>    # <record>
>    #  1.2 3.5
>    # </record>
>    # <record>
>    #  20.2 13.9
>    # </record>
>    # <record>
>    #  10.1 5.67
>    # </record>
>    # </data>
> 
> 
>  n = xmlNode("data", attrs = c("numVars" = 2, numRecords = 3))
>  n = append.xmlNode(n, xmlNode("varNames", xmlNode("string", "A"), xmlNode("string", "B")))
>  n = append.xmlNode(n, xmlNode("record", "1.2 3.5"))
>  n = append.xmlNode(n, xmlNode("record", "20.2 13.9"))
>  n = append.xmlNode(n, xmlNode("record", "10.1 5.67"))
> 
>  print(n)
<data numVars="2" numRecords="3">
 <varNames>
  <string>A</string>
  <string>B</string>
 </varNames>
 <record>1.2 3.5</record>
 <record>20.2 13.9</record>
 <record>10.1 5.67</record>
</data>
> 
> 
> ## Not run: 
> ##D    tmp <-  lapply(references, function(i) {
> ##D                                   if(!inherits(i, "XMLNode"))
> ##D                                     i <- xmlNode("reference", i)
> ##D                                   i
> ##D                               })
> ##D 
> ##D    r <- xmlNode("references")
> ##D    r[["references"]] <- append.xmlNode(r[["references"]], tmp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("asXMLNode")
> ### * asXMLNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asXMLNode
> ### Title: Converts non-XML node objects to XMLTextNode objects
> ### Aliases: asXMLNode coerce,XMLInternalNode,XMLNode-method
> ### Keywords: file
> 
> ### ** Examples
> 
>    # creates an XMLTextNode.
>  asXMLNode("a text node")
a text node
> 
>    # unaltered.
>  asXMLNode(xmlNode("p"))
<p/>
> 
> 
> 
> cleanEx()
> nameEx("catalogResolve")
> ### * catalogResolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: catalogResolve
> ### Title: Look up an element via the XML catalog mechanism
> ### Aliases: catalogResolve
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
> if(!exists("Sys.setenv")) Sys.setenv = Sys.putenv
> 
> Sys.setenv("XML_CATALOG_FILES" = system.file("exampleData", "catalog.xml", package = "XML"))
> 
> 
> 
> catalogResolve("-//OASIS//DTD DocBook XML V4.4//EN", "public")
[1] "file:///usr/share/xml/docbook44/docbookx.dtd"
> 
> catalogResolve("http://www.omegahat.org/XSL/foo.xsl")
[1] "/home/duncan/omegahat/XSLDocs/foo.xsl"
> 
> catalogResolve("http://www.omegahat.org/XSL/article.xsl", "uri")
[1] "/home/duncan/Projects/org/omegahat/Docs/XSL/article.xsl"
> catalogResolve("http://www.omegahat.org/XSL/math.xsl", "uri")
[1] "/home/duncan/omegahat/XSLDocs/math.xsl"
> 
> 
>   # This one does not resolve anything, returning an empty value.
> catalogResolve("http://www.oasis-open.org/docbook/xml/4.1.2/foo.xsl", "uri")
[1] NA
> 
> 
>    # Vectorized and returns NA for the first and /tmp/html.xsl
>    # for the second.
> 
>  catalogAdd("http://made.up.domain", "/tmp")
[1] TRUE
>  catalogResolve(c("ddas", "http://made.up.domain/html.xsl"), asIs = TRUE)
[1] "ddas"          "/tmp/html.xsl"
> 
> 
> 
> cleanEx()
> nameEx("catalogs")
> ### * catalogs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: catalogLoad
> ### Title: Manipulate XML catalog contents
> ### Aliases: catalogLoad catalogClearTable catalogAdd catalogDump
> ### Keywords: IO
> 
> ### ** Examples
> 
>   
>           # Add a rewrite rule
>      # 
>      # 	
>           catalogAdd(c("http://www.omegahat.org/XML" = system.file("XML", package = "XML")))
[1] TRUE
>           catalogAdd("http://www.omegahat.org/XML", system.file("XML", package = "XML"))
[1] TRUE
>           catalogAdd("http://www.r-project.org/doc/", paste(R.home(), "doc", "", sep = .Platform$file.sep))
[1] TRUE
> 	
>           # 
>      #          This shows how we can load a catalog and then resolve a system identifier 
>      #           that it maps.
>      # 	
>           catalogLoad(system.file("exampleData", "catalog.xml", package = "XML"))
[1] TRUE
> 
> 	  catalogResolve("docbook4.4.dtd", "system")
[1] "file:///usr/share/xml/docbook44/other_docbook.dtd"
> 	  catalogResolve("-//OASIS//DTD DocBook XML V4.4//EN", "public")
[1] "file:///usr/share/xml/docbook44/docbookx.dtd"
> 	
>    
> 
> 
> 
> cleanEx()
> nameEx("compareXMLDocs")
> ### * compareXMLDocs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareXMLDocs
> ### Title: Indicate differences between two XML documents
> ### Aliases: compareXMLDocs
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
> tt = 
+  '<x>
+      <a>text</a>
+      <b foo="1"/>
+      <c bar="me">
+         <d>a phrase</d>
+      </c>
+   </x>'
> 
>   a = xmlParse(tt, asText = TRUE)
>   b = xmlParse(tt, asText = TRUE)
>   d = getNodeSet(b, "//d")[[1]]
>   xmlName(d) = "bob"
>   addSibling(xmlParent(d), newXMLNode("c"))
[[1]]
<c/> 

>   
>   compareXMLDocs(a, b)
$inA
d 
1 

$inB
bob 
  1 

$countDiffs
 c 
-1 

> 
> 
> 
> cleanEx()
> nameEx("docName")
> ### * docName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: docName
> ### Title: Accessors for name of XML document
> ### Aliases: docName docName,XMLDocument-method
> ###   docName,XMLDocumentContent-method docName,XMLHashTree-method
> ###   docName,XMLInternalDocument-method docName,XMLInternalNode-method
> ###   docName,XMLHashTreeNode-method docName,NULL-method
> ###   docName,XMLNode-method docName<- docName<-,XMLInternalDocument-method
> ###   docName<-,XMLHashTree-method
> ### Keywords: IO programming
> 
> ### ** Examples
> 
>   f = system.file("exampleData", "catalog.xml",  package = "XML")
>   doc = xmlInternalTreeParse(f)
>   docName(doc)
[1] "/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/catalog.xml"
> 
>   doc = xmlInternalTreeParse("<a><b/></a>", asText = TRUE)
>       # an NA
>   docName(doc)
[1] NA
>   docName(doc) = "Simple XML example"
>   docName(doc)
[1] "Simple XML example"
> 
> 
> 
> cleanEx()
> nameEx("dtdElement")
> ### * dtdElement
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dtdElement
> ### Title: Gets the definition of an element or entity from a DTD.
> ### Aliases: dtdElement dtdEntity
> ### Keywords: file
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData","foo.dtd", package="XML")
>  foo.dtd <- parseDTD(dtdFile)
>  
>    # Get the definition of the `entry1' element
>  tmp <- dtdElement("variable", foo.dtd)
>  xmlAttrs(tmp)
$type
$name
[1] "type"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$unit
$name
[1] "unit"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$levels
$name
[1] "levels"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

> 
>  tmp <- dtdElement("entry1", foo.dtd)
> 
>   # Get the definition of the `img' entity
>  dtdEntity("img", foo.dtd)
NULL
> 
> 
> 
> cleanEx()
> nameEx("dtdElementValidEntry")
> ### * dtdElementValidEntry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dtdElementValidEntry
> ### Title: Determines whether an XML element allows a particular type of
> ###   sub-element.
> ### Aliases: dtdElementValidEntry.character
> ###   dtdElementValidEntry.XMLElementContent
> ###   dtdElementValidEntry.XMLElementDef dtdElementValidEntry.XMLOrContent
> ###   dtdElementValidEntry.XMLSequenceContent dtdElementValidEntry
> ### Keywords: file
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData", "foo.dtd",package="XML")
>  dtd <- parseDTD(dtdFile) 
>  
>   dtdElementValidEntry(dtdElement("variables",dtd), "variable")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("dtdIsAttribute")
> ### * dtdIsAttribute
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dtdIsAttribute
> ### Title: Query if a name is a valid attribute of a DTD element.
> ### Aliases: dtdIsAttribute
> ### Keywords: file
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData", "foo.dtd", package="XML")
>  foo.dtd <- parseDTD(dtdFile)
> 
>     # true
>   dtdIsAttribute("numRecords", "dataset", foo.dtd)
[1] TRUE
> 
>     # false
>   dtdIsAttribute("date", "dataset", foo.dtd)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("dtdValidElement")
> ### * dtdValidElement
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dtdValidElement
> ### Title: Determines whether an XML tag is valid within another.
> ### Aliases: dtdValidElement
> ### Keywords: file
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData", "foo.dtd", package="XML")
>  foo.dtd <- parseDTD(dtdFile)
> 
>   # The following are true.
>  dtdValidElement("variable","variables", dtd = foo.dtd)
[1] TRUE
>  dtdValidElement("record","dataset", dtd = foo.dtd)
[1] TRUE
> 
>   # This is false.
>  dtdValidElement("variable","dataset", dtd = foo.dtd)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("ensureNamespace")
> ### * ensureNamespace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ensureNamespace
> ### Title: Ensure that the node has a definition for particular XML
> ###   namespaces
> ### Aliases: ensureNamespace
> ### Keywords: IO
> 
> ### ** Examples
> 
>   doc = newXMLDoc()
>   top = newXMLNode("article", doc = doc)
>   ensureNamespace(top, c(r = "http://www.r-project.org"))
[1] "r"
>   b = newXMLNode("r:code", parent = top)
>   print(doc)
<?xml version="1.0"?>
<article xmlns:r="http://www.r-project.org">
  <r:code/>
</article>
 
> 
> 
> 
> cleanEx()
> nameEx("findXInclude")
> ### * findXInclude
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findXInclude
> ### Title: Find the XInclude node associated with an XML node
> ### Aliases: findXInclude
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
>  f = system.file("exampleData", "functionTemplate.xml", package = "XML")
> 
>  cat(readLines(f), "\n")
<?xml version="1.0" ?> <rh:help xmlns:rh="http://www.r-project.org/help" 	 xmlns:r="http://www.r-project.org"          xmlns:xi="http://www.w3.org/2001/XInclude">   <rh:topic> </rh:topic>    <rh:title> </rh:title>    <rh:description>      <para>       </para>    </rh:description>     <rh:arguments>    </rh:arguments>     <rh:value>      <para>      </para>    </rh:value>    <rh:details>      <para>      </para>    </rh:details>     <rh:seealso>    </rh:seealso>     <xi:include href="generalInfo.xml" xpointer="xmlns(rh=http://www.r-project.org/help) xpointer(//author|//authorgroup)">    </xi:include>     <rh:references>    </rh:references>     <rh:examples>       <r:init></r:init>       <rh:example id="">         <rh:title> </rh:title>         <rh:description><para> 	</para></rh:description>         <r:code> 	</r:code>       </rh:example>     </rh:examples>    <rh:keywords>     <rh:keyword></rh:keyword>   </rh:keywords>    <rh:versionIntroduced version="" />  </rh:help> 
> 
>  doc = xmlParse(f)
> 
>   # Get all the para nodes
>   # We just want to look at the 2nd and 3rd which are repeats of the
>   # first one.
>  a = getNodeSet(doc, "//author")
>  findXInclude(a[[1]])
                                                                      href 
                                                         "generalInfo.xml" 
                                                                  xpointer 
"xmlns(rh=http://www.r-project.org/help) xpointer(//author|//authorgroup)" 
> 
>  i = findXInclude(a[[1]], TRUE)
>  top = getSibling(i)
> 
>    # Determine the top-level included nodes
>  tmp = getSibling(i)
>  nodes = list()
>  while(!inherits(tmp, "XMLXIncludeEndNode")) {
+    nodes = c(nodes, tmp)
+    tmp = getSibling(tmp)
+  }
> 
> 
> 
> cleanEx()
> nameEx("free")
> ### * free
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: free
> ### Title: Release the specified object and clean up its memory usage
> ### Aliases: free free,XMLInternalDocument-method
> ### Keywords: IO
> 
> ### ** Examples
> 
>  f = system.file("exampleData", "boxplot.svg", package = "XML")
>  doc = xmlParse(f)
>  nodes = getNodeSet(doc, "//path")
>  rm(nodes)
>  # free(doc)
> 
> 
> 
> cleanEx()
> nameEx("genericSAXHandlers")
> ### * genericSAXHandlers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: genericSAXHandlers
> ### Title: SAX generic callback handler list
> ### Aliases: genericSAXHandlers
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Don't show: 
> # .InitSAXMethods()
> names(genericSAXHandlers())
[1] "startElement"          "endElement"            "comment"              
[4] "text"                  "processingInstruction" "entityDeclaration"    
> names(genericSAXHandlers(inc=c("startElement", "endElement", "text")))
[1] "startElement" "endElement"   "text"        
> names(genericSAXHandlers(ex=c("startElement", "endElement", "text")))
[1] "comment"               "processingInstruction" "entityDeclaration"    
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("getEncoding")
> ### * getEncoding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getEncoding
> ### Title: Determines the encoding for an XML document or node
> ### Aliases: getEncoding getEncoding,XMLInternalDocument-method
> ###   getEncoding,XMLInternalNode-method
> ### Keywords: IO
> 
> ### ** Examples
> 
>   f = system.file("exampleData", "charts.svg", package = "XML")
>   doc = xmlParse(f)
>   getEncoding(doc)
[1] "ISO-8859-1"
>   n = getNodeSet(doc, "//g/text")[[1]]
>   getEncoding(n)
[1] "ISO-8859-1"
> 
>   f = system.file("exampleData", "iTunes.plist", package = "XML")
>   doc = xmlParse(f)
>   getEncoding(doc)
[1] "UTF-8"
> 
> 
> 
> cleanEx()
> nameEx("getLineNumber")
> ### * getLineNumber
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getLineNumber
> ### Title: Determine the location - file & line number of an (internal) XML
> ###   node
> ### Aliases: getNodeLocation getLineNumber
> ### Keywords: IO
> 
> ### ** Examples
> 
> f = system.file("exampleData", "xysize.svg", package = "XML")
> doc = xmlParse(f)
> e = getNodeSet(doc, "//ellipse")
> sapply(e, getLineNumber)
 [1] 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71
> 
> 
> 
> cleanEx()
> nameEx("getNodeSet")
> ### * getNodeSet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getNodeSet
> ### Title: Find matching nodes in an internal XML tree/DOM
> ### Aliases: getNodeSet xpathApply xpathSApply matchNamespaces
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  doc = xmlParse(system.file("exampleData", "tagnames.xml", package = "XML"))
>  
>  els = getNodeSet(doc, "/doc//a[@status]")
>  sapply(els, function(el) xmlGetAttr(el, "status"))
[1] "xyz" "1"  
> 
>    # use of namespaces on an attribute.
>  getNodeSet(doc, "/doc//b[@x:status]", c(x = "http://www.omegahat.org"))
[[1]]
<b omegahat:status="foo">
  <r:d>
    <a status="xyz"/>
    <a/>
    <a status="1"/>
  </r:d>
</b> 

attr(,"class")
[1] "XMLNodeSet"
>  getNodeSet(doc, "/doc//b[@x:status='foo']", c(x = "http://www.omegahat.org"))
[[1]]
<b omegahat:status="foo">
  <r:d>
    <a status="xyz"/>
    <a/>
    <a status="1"/>
  </r:d>
</b> 

attr(,"class")
[1] "XMLNodeSet"
> 
>    # Because we know the namespace definitions are on /doc/a
>    # we can compute them directly and use them.
>  nsDefs = xmlNamespaceDefinitions(getNodeSet(doc, "/doc/a")[[1]])
>  ns = structure(sapply(nsDefs, function(x) x$uri), names = names(nsDefs))
>  getNodeSet(doc, "/doc//b[@omegahat:status='foo']", ns)[[1]]
<b omegahat:status="foo">
  <r:d>
    <a status="xyz"/>
    <a/>
    <a status="1"/>
  </r:d>
</b> 
> 
>  # free(doc) 
> 
>  #####
>  f = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML") 
>  e = xmlParse(f)
>  ans = getNodeSet(e, "//o:Cube[@currency='USD']", "o")
>  sapply(ans, xmlGetAttr, "rate")
   [1] "1.2664" "1.2721" "1.2684" "1.2737" "1.2685" "1.266"  "1.2713" "1.2684"
   [9] "1.2695" "1.2768" "1.2817" "1.2731" "1.2676" "1.2654" "1.2665" "1.2675"
  [17] "1.2723" "1.2677" "1.2709" "1.2713" "1.2713" "1.2731" "1.2793" "1.281" 
  [25] "1.2852" "1.2817" "1.2851" "1.2818" "1.2808" "1.28"   "1.2762" "1.2831"
  [33] "1.2812" "1.2812" "1.2919" "1.2802" "1.2879" "1.2793" "1.2725" "1.2718"
  [41] "1.2775" "1.2857" "1.2879" "1.2839" "1.285"  "1.2792" "1.2781" "1.2798"
  [49] "1.2759" "1.2767" "1.2664" "1.2737" "1.2587" "1.2636" "1.2633" "1.268" 
  [57] "1.2643" "1.2482" "1.2531" "1.2541" "1.2666" "1.2692" "1.2722" "1.2736"
  [65] "1.2752" "1.2778" "1.2735" "1.2794" "1.2791" "1.279"  "1.2713" "1.2529"
  [73] "1.257"  "1.2567" "1.2561" "1.2502" "1.2582" "1.2632" "1.2546" "1.2591"
  [81] "1.2651" "1.261"  "1.2563" "1.2571" "1.2572" "1.2659" "1.2735" "1.2789"
  [89] "1.2847" "1.2958" "1.2815" "1.2736" "1.2868" "1.2839" "1.2758" "1.2797"
  [97] "1.2755" "1.2851" "1.2841" "1.2753" "1.2767" "1.277"  "1.2882" "1.2817"
 [105] "1.2826" "1.2914" "1.2716" "1.2779" "1.2697" "1.2756" "1.2688" "1.2592"
 [113] "1.2622" "1.2643" "1.2537" "1.2414" "1.2425" "1.2425" "1.2365" "1.2315"
 [121] "1.2346" "1.2346" "1.2252" "1.2094" "1.2125" "1.2105" "1.2099" "1.2179"
 [129] "1.2312" "1.2262" "1.2217" "1.2063" "1.2104" "1.2096" "1.2012" "1.2084"
 [137] "1.2025" "1.1969" "1.2055" "1.2069" "1.2144" "1.2174" "1.2185" "1.2069"
 [145] "1.2026" "1.1948" "1.1922" "1.1919" "1.192"  "1.1914" "1.1913" "1.2017"
 [153] "1.202"  "1.1921" "1.1954" "1.1875" "1.1852" "1.1896" "1.1957" "1.1875"
 [161] "1.1906" "1.1932" "1.1863" "1.1858" "1.1904" "1.1898" "1.1888" "1.197" 
 [169] "1.1972" "1.1948" "1.1973" "1.1981" "1.2061" "1.2066" "1.2092" "1.2118"
 [177] "1.2082" "1.2172" "1.2254" "1.2294" "1.2272" "1.2277" "1.2068" "1.2073"
 [185] "1.2125" "1.2075" "1.2112" "1.2039" "1.2113" "1.2088" "1.2064" "1.2078"
 [193] "1.2093" "1.2088" "1.2083" "1.1875" "1.1826" "1.1797" "1.1825" "1.1916"
 [201] "1.1852" "1.1859" "1.1822" "1.1872" "1.1955" "1.1977" "1.1983" "1.1999"
 [209] "1.202"  "1.1925" "1.1925" "1.1785" "1.1764" "1.171"  "1.1783" "1.1767"
 [217] "1.1697" "1.1745" "1.1769" "1.1793" "1.1726" "1.1763" "1.1783" "1.1776"
 [225] "1.1701" "1.1811" "1.1679" "1.1692" "1.1677" "1.1667" "1.1713" "1.1697"
 [233] "1.1762" "1.1738" "1.1741" "1.1824" "1.1933" "1.2041" "1.1992" "1.2008"
 [241] "1.2023" "1.2138" "1.213"  "1.2059" "1.2017" "1.1944" "1.2012" "1.1953"
 [249] "1.195"  "1.1937" "1.2022" "1.1999" "1.198"  "1.2008" "1.2022" "1.2088"
 [257] "1.2144" "1.2061" "1.1947" "1.1938" "1.1933" "1.2042" "1.2063" "1.2037"
 [265] "1.2005" "1.2031" "1.2118" "1.2224" "1.2225" "1.2154" "1.2139" "1.2243"
 [273] "1.2223" "1.2314" "1.2276" "1.2313" "1.2415" "1.2418" "1.2451" "1.2483"
 [281] "1.2538" "1.2541" "1.2388" "1.2198" "1.2181" "1.2289" "1.2307" "1.2272"
 [289] "1.2211" "1.2233" "1.2231" "1.2183" "1.2213" "1.2296" "1.2313" "1.2374"
 [297] "1.2457" "1.2405" "1.2377" "1.2367" "1.237"  "1.2386" "1.2319" "1.2308"
 [305] "1.2217" "1.2219" "1.2093" "1.21"   "1.199"  "1.1987" "1.2065" "1.2143"
 [313] "1.2187" "1.2063" "1.1965" "1.2054" "1.2073" "1.2067" "1.2184" "1.2166"
 [321] "1.2006" "1.1904" "1.1957" "1.1913" "1.1883" "1.1894" "1.2087" "1.2092"
 [329] "1.2054" "1.2095" "1.2164" "1.2082" "1.2066" "1.2111" "1.2092" "1.221" 
 [337] "1.2177" "1.2115" "1.2069" "1.211"  "1.2062" "1.2229" "1.2239" "1.2324"
 [345] "1.2285" "1.2272" "1.2289" "1.2263" "1.2228" "1.2331" "1.2472" "1.2551"
 [353] "1.2523" "1.2564" "1.2617" "1.2548" "1.2607" "1.2642" "1.2621" "1.2636"
 [361] "1.2616" "1.2635" "1.2771" "1.2882" "1.2854" "1.2824" "1.2947" "1.2954"
 [369] "1.2953" "1.2856" "1.2863" "1.2957" "1.2905" "1.292"  "1.2981" "1.2966"
 [377] "1.3077" "1.3058" "1.3049" "1.2996" "1.2967" "1.2868" "1.282"  "1.2922"
 [385] "1.2985" "1.2971" "1.2819" "1.2923" "1.286"  "1.281"  "1.2883" "1.2959"
 [393] "1.2964" "1.2943" "1.2926" "1.2982" "1.305"  "1.3175" "1.3199" "1.3279"
 [401] "1.3378" "1.3373" "1.3383" "1.3372" "1.3416" "1.3409" "1.3346" "1.3246"
 [409] "1.3197" "1.3115" "1.3144" "1.3101" "1.3216" "1.3257" "1.3165" "1.326" 
 [417] "1.3203" "1.3193" "1.3055" "1.3039" "1.3041" "1.304"  "1.3016" "1.2967"
 [425] "1.2855" "1.2777" "1.2762" "1.2764" "1.2844" "1.2958" "1.3001" "1.3061"
 [433] "1.3027" "1.3035" "1.3035" "1.3026" "1.3005" "1.3025" "1.3065" "1.2963"
 [441] "1.2936" "1.3083" "1.306"  "1.3085" "1.3091" "1.3232" "1.3139" "1.3143"
 [449] "1.3103" "1.32"   "1.3183" "1.3224" "1.3365" "1.3507" "1.3621" "1.3604"
 [457] "1.3608" "1.3633" "1.3527" "1.3542" "1.3456" "1.3384" "1.3394" "1.3378"
 [465] "1.3264" "1.3401" "1.3383" "1.3317" "1.3268" "1.3191" "1.3305" "1.33"  
 [473] "1.3456" "1.3435" "1.33"   "1.3314" "1.3294" "1.3295" "1.3247" "1.3238"
 [481] "1.3213" "1.3146" "1.3089" "1.3033" "1.302"  "1.3024" "1.3026" "1.2971"
 [489] "1.2955" "1.2921" "1.289"  "1.2977" "1.2911" "1.2917" "1.2856" "1.2874"
 [497] "1.2754" "1.2705" "1.2748" "1.2737" "1.2711" "1.2792" "1.2784" "1.2792"
 [505] "1.2606" "1.2606" "1.259"  "1.2509" "1.2474" "1.2414" "1.2377" "1.2267"
 [513] "1.2312" "1.2392" "1.2315" "1.2301" "1.2282" "1.2304" "1.2305" "1.2413"
 [521] "1.2409" "1.2323" "1.2335" "1.2254" "1.2309" "1.2315" "1.2245" "1.2276"
 [529] "1.2132" "1.2211" "1.2158" "1.2238" "1.2237" "1.2236" "1.2219" "1.2191"
 [537] "1.2039" "1.2079" "1.2071" "1.2175" "1.2172" "1.2168" "1.2111" "1.2047"
 [545] "1.2085" "1.21"   "1.2081" "1.2139" "1.225"  "1.2293" "1.2359" "1.2331"
 [553] "1.2338" "1.2337" "1.2219" "1.2256" "1.2233" "1.2279" "1.2247" "1.2064"
 [561] "1.2042" "1.1983" "1.2022" "1.2055" "1.2039" "1.2026" "1.2034" "1.2168"
 [569] "1.2163" "1.2191" "1.2268" "1.2296" "1.2385" "1.2412" "1.2353" "1.2374"
 [577] "1.2381" "1.2372" "1.2397" "1.2372" "1.2348" "1.2357" "1.2309" "1.2288"
 [585] "1.2148" "1.2168" "1.2155" "1.2169" "1.2208" "1.2138" "1.2122" "1.2087"
 [593] "1.2091" "1.2112" "1.2042" "1.2045" "1.2058" "1.2051" "1.2001" "1.2006"
 [601] "1.2052" "1.2157" "1.2294" "1.2319" "1.2203" "1.2226" "1.2276" "1.2231"
 [609] "1.2198" "1.2246" "1.2165" "1.2106" "1.2063" "1.1968" "1.2031" "1.1922"
 [617] "1.1989" "1.1983" "1.2023" "1.1802" "1.1823" "1.1857" "1.1804" "1.1843"
 [625] "1.2073" "1.2116" "1.2126" "1.2061" "1.1953" "1.1947" "1.1826" "1.1907"
 [633] "1.1887" "1.1851" "1.1885" "1.1873" "1.1836" "1.1926" "1.2044" "1.1932"
 [641] "1.1912" "1.1924" "1.1975" "1.2096" "1.2101" "1.209"  "1.2058" "1.2318"
 [649] "1.232"  "1.2224" "1.2187" "1.2118" "1.2173" "1.2132" "1.2196" "1.2276"
 [657] "1.2353" "1.2344" "1.2261" "1.2251" "1.235"  "1.2278" "1.2235" "1.2256"
 [665] "1.2299" "1.2361" "1.2356" "1.2192" "1.2147" "1.2143" "1.2402" "1.2484"
 [673] "1.2418" "1.2444" "1.2629" "1.2595" "1.2576" "1.2663" "1.2724" "1.2824"
 [681] "1.2858" "1.2741" "1.2816" "1.2802" "1.268"  "1.2764" "1.2713" "1.2529"
 [689] "1.2583" "1.2524" "1.2585" "1.2461" "1.2384" "1.2468" "1.2563" "1.2517"
 [697] "1.2575" "1.2692" "1.271"  "1.2607" "1.2536" "1.2373" "1.2493" "1.2635"
 [705] "1.2692" "1.2749" "1.2828" "1.2737" "1.2634" "1.2679" "1.2756" "1.2657"
 [713] "1.2592" "1.263"  "1.2496" "1.2499" "1.2407" "1.2392" "1.2434" "1.2418"
 [721] "1.2403" "1.2337" "1.2339" "1.223"  "1.2254" "1.2187" "1.2239" "1.2258"
 [729] "1.2218" "1.2087" "1.2074" "1.2102" "1.1975" "1.2019" "1.1994" "1.1902"
 [737] "1.1828" "1.1766" "1.1823" "1.1899" "1.1909" "1.191"  "1.1778" "1.1802"
 [745] "1.1765" "1.168"  "1.16"   "1.1497" "1.1483" "1.1424" "1.1449" "1.1473"
 [753] "1.1468" "1.1589" "1.1622" "1.1736" "1.1684" "1.1673" "1.1748" "1.1781"
 [761] "1.1786" "1.1694" "1.1623" "1.1629" "1.1579" "1.1615" "1.1669" "1.1634"
 [769] "1.1688" "1.1788" "1.1788" "1.1781" "1.1768" "1.1579" "1.1686" "1.1692"
 [777] "1.1671" "1.1652" "1.1413" "1.1487" "1.1493" "1.1466" "1.1464" "1.1468"
 [785] "1.1312" "1.129"  "1.1212" "1.1235" "1.1281" "1.1172" "1.1217" "1.1172"
 [793] "1.1135" "1.1071" "1.0923" "1.0818" "1.0783" "1.0849" "1.0965" "1.0927"
 [801] "1.0828" "1.0907" "1.0816" "1.0888" "1.0894" "1.1009" "1.1109" "1.1065"
 [809] "1.1188" "1.1247" "1.127"  "1.1277" "1.1312" "1.1295" "1.1326" "1.1353"
 [817] "1.1392" "1.1333" "1.1307" "1.1169" "1.1318" "1.142"  "1.1462" "1.1489"
 [825] "1.1477" "1.1467" "1.1401" "1.1343" "1.1284" "1.1205" "1.1231" "1.1138"
 [833] "1.1319" "1.1299" "1.1315" "1.1342" "1.1355" "1.1326" "1.136"  "1.1466"
 [841] "1.1457" "1.1535" "1.1543" "1.1427" "1.1413" "1.1432" "1.1551" "1.1565"
 [849] "1.1539" "1.1655" "1.1655" "1.1699" "1.1797" "1.1854" "1.1751" "1.1734"
 [857] "1.1748" "1.1699" "1.1726" "1.1813" "1.1775" "1.1691" "1.1723" "1.1672"
 [865] "1.1822" "1.1756" "1.1738" "1.1901" "1.1813" "1.179"  "1.172"  "1.1689"
 [873] "1.1644" "1.1652" "1.1492" "1.1458" "1.1499" "1.1518" "1.1597" "1.1466"
 [881] "1.1435" "1.1427" "1.1344" "1.1218" "1.1239" "1.1131" "1.0956" "1.1025"
 [889] "1.0973" "1.1008" "1.0944" "1.0971" "1.092"  "1.0836" "1.0784" "1.0737"
 [897] "1.0735" "1.0805" "1.0742" "1.066"  "1.0582" "1.072"  "1.0702" "1.083" 
 [905] "1.0891" "1.0895" "1.073"  "1.0723" "1.0667" "1.0691" "1.0634" "1.0572"
 [913] "1.0592" "1.057"  "1.0586" "1.0801" "1.0775" "1.0864" "1.1028" "1.108" 
 [921] "1.1042" "1.1039" "1.0963" "1.0966" "1.0919" "1.08"   "1.0782" "1.0822"
 [929] "1.0753" "1.0774" "1.0721" "1.0838" "1.0763" "1.0717" "1.0714" "1.0716"
 [937] "1.0793" "1.0758" "1.0731" "1.0706" "1.0808" "1.0789" "1.0813" "1.091" 
 [945] "1.0822" "1.0729" "1.0816" "1.0748" "1.0868" "1.0808" "1.087"  "1.0784"
 [953] "1.0757" "1.0718" "1.0653" "1.0653" "1.0652" "1.0564" "1.0526" "1.0577"
 [961] "1.0549" "1.0503" "1.0507" "1.0377" "1.0425" "1.0488" "1.0392" "1.0446"
 [969] "1.0487" "1.0422" "1.0376" "1.0296" "1.0282" "1.0255" "1.0273" "1.024" 
 [977] "1.0307" "1.0212" "1.0221" "1.0156" "1.0067" "1.0111" "1.0093" "1.0006"
 [985] "0.9991" "1.0018" "0.9967" "0.9871" "0.9927" "0.9934" "0.9927" "0.991" 
 [993] "0.9905" "1.0024" "1.0034" "1.0019" "1.0125" "1.0065" "1.0029" "1.0095"
[1001] "1.0068" "1.0081" "1.0126" "1.0107" "1.0013" "0.9955" "1.0024" "0.9944"
[1009] "0.9974" "0.9864" "0.9825" "0.982"  "0.9745" "0.9763" "0.9738" "0.9775"
[1017] "0.9768" "0.9748" "0.9735" "0.9763" "0.9823" "0.981"  "0.9873" "0.9857"
[1025] "0.9875" "0.9814" "0.98"   "0.9808" "0.9865" "0.989"  "0.9835" "0.9861"
[1033] "0.986"  "0.9779" "0.9796" "0.9771" "0.9828" "0.9831" "0.979"  "0.9814"
[1041] "0.9725" "0.9649" "0.9683" "0.981"  "0.9757" "0.9749" "0.976"  "0.9794"
[1049] "0.9918" "0.9975" "0.9947" "0.991"  "0.9821" "0.9833" "0.9843" "0.9826"
[1057] "0.9774" "0.9701" "0.9697" "0.977"  "0.9762" "0.9792" "0.9799" "0.9825"
[1065] "0.9777" "0.9857" "0.9799" "0.978"  "0.9729" "0.9687" "0.9698" "0.9689"
[1073] "0.9836" "0.9873" "0.976"  "0.9783" "0.9835" "0.9821" "1.0008" "1.0014"
[1081] "0.9915" "0.991"  "1.0086" "1.0146" "1.0058" "1.0064" "1.0127" "1.0024"
[1089] "0.9873" "0.9836" "0.9898" "0.993"  "0.9828" "0.9725" "0.979"  "0.978" 
[1097] "0.9838" "0.9913" "0.9975" "0.9824" "0.9917" "0.9712" "0.9781" "0.9636"
[1105] "0.9592" "0.9561" "0.9484" "0.9426" "0.9478" "0.9417" "0.9452" "0.9417"
[1113] "0.9459" "0.9452" "0.9386" "0.9371" "0.9435" "0.9313" "0.9387" "0.9375"
[1121] "0.932"  "0.9255" "0.919"  "0.9188" "0.9213" "0.926"  "0.9213" "0.9202"
[1129] "0.9152" "0.9124" "0.903"  "0.9062" "0.9118" "0.9118" "0.9061" "0.9088"
[1137] "0.9125" "0.9144" "0.9083" "0.9032" "0.9008" "0.9038" "0.8971" "0.8969"
[1145] "0.8892" "0.8872" "0.8882" "0.8886" "0.8895" "0.888"  "0.8803" "0.8802"
[1153] "0.8803" "0.8794" "0.8798" "0.8763" "0.8778" "0.8786" "0.8818" "0.8803"
[1161] "0.8786" "0.8724" "0.8746" "0.8737" "0.8759" "0.8795" "0.8817" "0.8814"
[1169] "0.8829" "0.8792" "0.8853" "0.8803" "0.8734" "0.8733" "0.8741" "0.8797"
[1177] "0.8764" "0.8712" "0.8682" "0.8649" "0.8679" "0.8651" "0.8649" "0.8682"
[1185] "0.8724" "0.8747" "0.8701" "0.8743" "0.8692" "0.8715" "0.8705" "0.8693"
[1193] "0.8731" "0.8753" "0.8794" "0.874"  "0.8664" "0.8664" "0.8683" "0.8644"
[1201] "0.8632" "0.8637" "0.8642" "0.8624" "0.8578" "0.8663" "0.8767" "0.8856"
[1209] "0.883"  "0.884"  "0.881"  "0.8819" "0.8817" "0.8922" "0.8927" "0.8919"
[1217] "0.8909" "0.8921" "0.8909" "0.8905" "0.8954" "0.9036" "0.9038" "0.8813"
[1225] "0.8823" "0.8798" "0.8943" "0.8973" "0.8983" "0.9012" "0.9049" "0.9016"
[1233] "0.8975" "0.8938" "0.8908" "0.885"  "0.8911" "0.8889" "0.8919" "0.8902"
[1241] "0.8925" "0.8898" "0.8887" "0.8831" "0.8788" "0.8818" "0.8795" "0.8778"
[1249] "0.8791" "0.8824" "0.8793" "0.8845" "0.8825" "0.8803" "0.8842" "0.8919"
[1257] "0.893"  "0.8972" "0.9014" "0.8961" "0.8961" "0.9056" "0.9097" "0.9042"
[1265] "0.9064" "0.9005" "0.8911" "0.8889" "0.8917" "0.8887" "0.8969" "0.9009"
[1273] "0.9026" "0.9022" "0.9052" "0.9097" "0.904"  "0.9062" "0.9136" "0.9193"
[1281] "0.9214" "0.9174" "0.9117" "0.9209" "0.9189" "0.9125" "0.9131" "0.9205"
[1289] "0.9219" "0.9176" "0.9164" "0.92"   "0.9259" "0.9258" "0.9256" "0.9269"
[1297] "0.9219" "0.906"  "0.9052" "0.8964" "0.9047" "0.8952" "0.8855" "0.8891"
[1305] "0.897"  "0.9072" "0.9158" "0.9095" "0.9122" "0.9042" "0.909"  "0.9108"
[1313] "0.9112" "0.9216" "0.9128" "0.9149" "0.9138" "0.9144" "0.9114" "0.8968"
[1321] "0.8991" "0.8936" "0.8853" "0.8763" "0.8768" "0.8805" "0.8806" "0.8788"
[1329] "0.8817" "0.8755" "0.8751" "0.8768" "0.8764" "0.8793" "0.8708" "0.8676"
[1337] "0.8776" "0.8723" "0.863"  "0.8516" "0.8583" "0.8539" "0.8538" "0.8611"
[1345] "0.8545" "0.8459" "0.8384" "0.8422" "0.8453" "0.8497" "0.8455" "0.848" 
[1353] "0.8511" "0.8622" "0.8611" "0.8607" "0.8528" "0.8552" "0.8513" "0.8563"
[1361] "0.8581" "0.8662" "0.8492" "0.8542" "0.8474" "0.8494" "0.8468" "0.8466"
[1369] "0.8543" "0.8465" "0.8513" "0.8478" "0.848"  "0.8558" "0.8552" "0.8584"
[1377] "0.8591" "0.8604" "0.8585" "0.8685" "0.8754" "0.8777" "0.8815" "0.8834"
[1385] "0.8768" "0.8745" "0.8773" "0.885"  "0.8827" "0.8866" "0.8919" "0.8939"
[1393] "0.8903" "0.8907" "0.8876" "0.9023" "0.9013" "0.8947" "0.8973" "0.9002"
[1401] "0.8989" "0.8827" "0.8778" "0.8791" "0.8849" "0.884"  "0.8945" "0.9018"
[1409] "0.894"  "0.902"  "0.9032" "0.8845" "0.8772" "0.8832" "0.884"  "0.886" 
[1417] "0.8952" "0.8935" "0.8922" "0.8889" "0.899"  "0.902"  "0.8996" "0.8947"
[1425] "0.9064" "0.9182" "0.9202" "0.9272" "0.9357" "0.9312" "0.9307" "0.9279"
[1433] "0.9305" "0.9363" "0.9269" "0.9248" "0.9163" "0.9105" "0.9064" "0.9056"
[1441] "0.9146" "0.907"  "0.9213" "0.9113" "0.909"  "0.9178" "0.9275" "0.9288"
[1449] "0.9227" "0.922"  "0.9325" "0.9322" "0.9425" "0.9407" "0.9406" "0.9293"
[1457] "0.9197" "0.9193" "0.9228" "0.9146" "0.9294" "0.9407" "0.929"  "0.94"  
[1465] "0.9404" "0.9396" "0.9412" "0.9428" "0.9545" "0.9523" "0.9412" "0.9401"
[1473] "0.9497" "0.9545" "0.9458" "0.953"  "0.9423" "0.9305" "0.9285" "0.931" 
[1481] "0.924"  "0.9146" "0.9059" "0.8903" "0.8966" "0.8984" "0.8839" "0.8748"
[1489] "0.8782" "0.8804" "0.8895" "0.8943" "0.8828" "0.881"  "0.8908" "0.8735"
[1497] "0.8684" "0.865"  "0.8561" "0.8406" "0.8436" "0.8427" "0.8429" "0.8474"
[1505] "0.8488" "0.8535" "0.8569" "0.8596" "0.8583" "0.862"  "0.8673" "0.8531"
[1513] "0.8559" "0.8587" "0.8667" "0.873"  "0.8646" "0.8554" "0.8417" "0.8482"
[1521] "0.8324" "0.8252" "0.8307" "0.8386" "0.8377" "0.8452" "0.8411" "0.8525"
[1529] "0.8496" "0.8511" "0.8627" "0.8648" "0.872"  "0.8721" "0.8695" "0.8703"
[1537] "0.8786" "0.873"  "0.8763" "0.8802" "0.8765" "0.8832" "0.8861" "0.8757"
[1545] "0.877"  "0.889"  "0.8524" "0.8476" "0.8541" "0.8526" "0.8615" "0.8693"
[1553] "0.8654" "0.8614" "0.8609" "0.8735" "0.8676" "0.8818" "0.8886" "0.9"   
[1561] "0.8902" "0.8906" "0.8909" "0.8965" "0.9007" "0.9021" "0.9012" "0.8918"
[1569] "0.8972" "0.9023" "0.9127" "0.914"  "0.9072" "0.9118" "0.9011" "0.9132"
[1577] "0.9031" "0.8973" "0.9047" "0.9084" "0.9031" "0.9028" "0.9142" "0.9264"
[1585] "0.9243" "0.9276" "0.9389" "0.939"  "0.941"  "0.9332" "0.9363" "0.922" 
[1593] "0.9216" "0.9353" "0.9352" "0.9344" "0.9349" "0.9499" "0.9527" "0.9523"
[1601] "0.9483" "0.9542" "0.9537" "0.9487" "0.9493" "0.9556" "0.9504" "0.9415"
[1609] "0.9401" "0.9327" "0.9413" "0.9405" "0.947"  "0.9538" "0.964"  "0.9565"
[1617] "0.9524" "0.9636" "0.9583" "0.9527" "0.949"  "0.9668" "0.9554" "0.9485"
[1625] "0.9433" "0.9355" "0.933"  "0.9303" "0.9359" "0.9262" "0.9143" "0.8981"
[1633] "0.9098" "0.9111" "0.9"    "0.8875" "0.8942" "0.8922" "0.9065" "0.9147"
[1641] "0.9029" "0.9079" "0.9107" "0.8978" "0.8952" "0.8984" "0.8947" "0.8913"
[1649] "0.9116" "0.9085" "0.9163" "0.9193" "0.9302" "0.9376" "0.9461" "0.9497"
[1657] "0.9573" "0.954"  "0.9537" "0.9576" "0.9594" "0.959"  "0.9564" "0.9625"
[1665] "0.9673" "0.9538" "0.9564" "0.9553" "0.9555" "0.9568" "0.9647" "0.9712"
[1673] "0.9715" "0.9656" "0.9603" "0.9701" "0.9715" "0.9672" "0.9663" "0.9647"
[1681] "0.962"  "0.9716" "0.9613" "0.9616" "0.9543" "0.9593" "0.964"  "0.9659"
[1689] "0.9725" "0.9667" "0.9714" "0.9639" "0.9813" "0.9898" "1.0068" "1.0022"
[1697] "0.9857" "0.9857" "0.9919" "0.9804" "0.9778" "0.9867" "0.9801" "0.9868"
[1705] "0.9934" "0.9903" "0.9767" "0.9835" "0.9748" "0.9717" "0.971"  "0.9791"
[1713] "0.9848" "0.9976" "1.0019" "1.0008" "1.0027" "1.0097" "1.0089" "1.0105"
[1721] "1.0093" "1.0094" "1.0225" "1.0276" "1.0308" "1.0256" "1.0229" "1.0284"
[1729] "1.0388" "1.0368" "1.0305" "1.009"  "1.0046" "1.0072" "1.0089" "1.0134"
[1737] "1.0142" "1.0089" "1.0074" "1.0084" "1.0096" "1.0128" "1.0146" "1.0021"
[1745] "1.0038" "1.0128" "1.0141" "1.0175" "1.0236" "1.0239" "1.0182" "1.0015"
[1753] "1.0057" "1.0091" "1.0097" "1.0077" "1.0101" "1.0194" "1.0215" "1.0315"
[1761] "1.0311" "1.0279" "1.038"  "1.0408" "1.0336" "1.0301" "1.0308" "1.0406"
[1769] "1.0402" "1.0424" "1.0405" "1.0408" "1.0504" "1.0491" "1.0507" "1.0572"
[1777] "1.0453" "1.0534" "1.0552" "1.0633" "1.0683" "1.0758" "1.0797" "1.0777"
[1785] "1.0818" "1.0868" "1.0869" "1.0758" "1.0778" "1.0668" "1.0631" "1.0657"
[1793] "1.0729" "1.0737" "1.0686" "1.0719" "1.0728" "1.0665" "1.0563" "1.0483"
[1801] "1.0414" "1.0476" "1.043"  "1.0509" "1.0388" "1.0406" "1.0397" "1.0372"
[1809] "1.0369" "1.0362" "1.0342" "1.052"  "1.0592" "1.0613" "1.0565" "1.0594"
[1817] "1.0682" "1.0662" "1.0613" "1.0573" "1.0454" "1.045"  "1.0452" "1.0433"
[1825] "1.0512" "1.0606" "1.0667" "1.0517" "1.0517" "1.0527" "1.0553" "1.0667"
[1833] "1.0638" "1.0668" "1.0737" "1.0705" "1.074"  "1.0791" "1.0761" "1.0645"
[1841] "1.0665" "1.0694" "1.068"  "1.0603" "1.0627" "1.0698" "1.0496" "1.0499"
[1849] "1.0462" "1.041"  "1.0146" "1.0202" "1.0201" "1.0168" "1.0183" "1.0124"
[1857] "1.0204" "1.0182" "1.0222" "1.0221" "1.0232" "1.0241" "1.0264" "1.0328"
[1865] "1.0364" "1.0388" "1.0443" "1.0321" "1.028"  "1.0313" "1.0339" "1.0388"
[1873] "1.034"  "1.0345" "1.0392" "1.0437" "1.0474" "1.0474" "1.0466" "1.0385"
[1881] "1.0316" "1.0315" "1.0382" "1.0382" "1.0434" "1.0456" "1.0479" "1.0473"
[1889] "1.0535" "1.0627" "1.0585" "1.0572" "1.0639" "1.0634" "1.069"  "1.0685"
[1897] "1.0676" "1.0622" "1.0645" "1.0732" "1.0735" "1.0786" "1.0799" "1.0667"
[1905] "1.0564" "1.0589" "1.0597" "1.0604" "1.0666" "1.063"  "1.0614" "1.0634"
[1913] "1.0581" "1.0586" "1.0646" "1.0636" "1.0668" "1.0786" "1.0787" "1.0765"
[1921] "1.0867" "1.0778" "1.0818" "1.0812" "1.0726" "1.0752" "1.0772" "1.0772"
[1929] "1.0742" "1.0711" "1.0692" "1.0815" "1.0898" "1.0928" "1.0896" "1.0864"
[1937] "1.0915" "1.1012" "1.0966" "1.0901" "1.0949" "1.0932" "1.0891" "1.0953"
[1945] "1.0863" "1.0908" "1.0834" "1.0866" "1.0899" "1.0887" "1.0986" "1.1018"
[1953] "1.1031" "1.1037" "1.0969" "1.0992" "1.1163" "1.1232" "1.1253" "1.1176"
[1961] "1.1238" "1.1244" "1.1312" "1.1342" "1.1333" "1.1246" "1.1292" "1.1263"
[1969] "1.1337" "1.1337" "1.1338" "1.1384" "1.141"  "1.1529" "1.1582" "1.1584"
[1977] "1.1567" "1.1572" "1.1575" "1.1616" "1.1612" "1.1626" "1.1653" "1.1744"
[1985] "1.152"  "1.1569" "1.1659" "1.1632" "1.1743" "1.179"  "1.1789"
> 
>   # or equivalently
>  ans = xpathApply(e, "//o:Cube[@currency='USD']", xmlGetAttr, "rate", namespaces = "o")
>  # free(e)
> 
> 
> 
>   # Using a namespace
>  f = system.file("exampleData", "SOAPNamespaces.xml", package = "XML") 
>  z = xmlParse(f)
>  getNodeSet(z, "/a:Envelope/a:Body", c("a" = "http://schemas.xmlsoap.org/soap/envelope/"))
[[1]]
<SOAP-ENV:Body>
  <namesp1:c2fResponse xmlns:namesp1="http://www.soaplite.com/Temperatures">
    <s-gensym3 xsi:type="xsd:float">99.5</s-gensym3>
  </namesp1:c2fResponse>
</SOAP-ENV:Body> 

attr(,"class")
[1] "XMLNodeSet"
>  getNodeSet(z, "//a:Body", c("a" = "http://schemas.xmlsoap.org/soap/envelope/"))
[[1]]
<SOAP-ENV:Body>
  <namesp1:c2fResponse xmlns:namesp1="http://www.soaplite.com/Temperatures">
    <s-gensym3 xsi:type="xsd:float">99.5</s-gensym3>
  </namesp1:c2fResponse>
</SOAP-ENV:Body> 

attr(,"class")
[1] "XMLNodeSet"
>  # free(z)
> 
> 
>   # Get two items back with namespaces
>  f = system.file("exampleData", "gnumeric.xml", package = "XML") 
>  z = xmlParse(f)
>  getNodeSet(z, "//gmr:Item/gmr:name", c(gmr="http://www.gnome.org/gnumeric/v2"))
[[1]]
<gmr:name>Application</gmr:name> 

[[2]]
<gmr:name>Author</gmr:name> 

attr(,"class")
[1] "XMLNodeSet"
> 
>  #free(z)
> 
>  #####
>  # European Central Bank (ECB) exchange rate data
> 
>   # Data is available from "http://www.ecb.int/stats/eurofxref/eurofxref-hist.xml"
>   # or locally.
> 
>  uri = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML")
>  doc = xmlParse(uri)
> 
>    # The default namespace for all elements is given by
>  namespaces <- c(ns="http://www.ecb.int/vocabulary/2002-08-01/eurofxref")
> 
> 
>      # Get the data for Slovenian currency for all time periods.
>      # Find all the nodes of the form <Cube currency="SIT"...>
> 
>  slovenia = getNodeSet(doc, "//ns:Cube[@currency='SIT']", namespaces )
> 
>     # Now we have a list of such nodes, loop over them 
>     # and get the rate attribute
>  rates = as.numeric( sapply(slovenia, xmlGetAttr, "rate") )
>     # Now put the date on each element
>     # find nodes of the form <Cube time=".." ... >
>     # and extract the time attribute
>  names(rates) = sapply(getNodeSet(doc, "//ns:Cube[@time]", namespaces ), 
+                       xmlGetAttr, "time")
> 
>     #  Or we could turn these into dates with strptime()
>  strptime(names(rates), "%Y-%m-%d")
   [1] "2006-10-06" "2006-10-05" "2006-10-04" "2006-10-03" "2006-10-02"
   [6] "2006-09-29" "2006-09-28" "2006-09-27" "2006-09-26" "2006-09-25"
  [11] "2006-09-22" "2006-09-21" "2006-09-20" "2006-09-19" "2006-09-18"
  [16] "2006-09-15" "2006-09-14" "2006-09-13" "2006-09-12" "2006-09-11"
  [21] "2006-09-08" "2006-09-07" "2006-09-06" "2006-09-05" "2006-09-04"
  [26] "2006-09-01" "2006-08-31" "2006-08-30" "2006-08-29" "2006-08-28"
  [31] "2006-08-25" "2006-08-24" "2006-08-23" "2006-08-22" "2006-08-21"
  [36] "2006-08-18" "2006-08-17" "2006-08-16" "2006-08-15" "2006-08-14"
  [41] "2006-08-11" "2006-08-10" "2006-08-09" "2006-08-08" "2006-08-07"
  [46] "2006-08-04" "2006-08-03" "2006-08-02" "2006-08-01" "2006-07-31"
  [51] "2006-07-28" "2006-07-27" "2006-07-26" "2006-07-25" "2006-07-24"
  [56] "2006-07-21" "2006-07-20" "2006-07-19" "2006-07-18" "2006-07-17"
  [61] "2006-07-14" "2006-07-13" "2006-07-12" "2006-07-11" "2006-07-10"
  [66] "2006-07-07" "2006-07-06" "2006-07-05" "2006-07-04" "2006-07-03"
  [71] "2006-06-30" "2006-06-29" "2006-06-28" "2006-06-27" "2006-06-26"
  [76] "2006-06-23" "2006-06-22" "2006-06-21" "2006-06-20" "2006-06-19"
  [81] "2006-06-16" "2006-06-15" "2006-06-14" "2006-06-13" "2006-06-12"
  [86] "2006-06-09" "2006-06-08" "2006-06-07" "2006-06-06" "2006-06-05"
  [91] "2006-06-02" "2006-06-01" "2006-05-31" "2006-05-30" "2006-05-29"
  [96] "2006-05-26" "2006-05-25" "2006-05-24" "2006-05-23" "2006-05-22"
 [101] "2006-05-19" "2006-05-18" "2006-05-17" "2006-05-16" "2006-05-15"
 [106] "2006-05-12" "2006-05-11" "2006-05-10" "2006-05-09" "2006-05-08"
 [111] "2006-05-05" "2006-05-04" "2006-05-03" "2006-05-02" "2006-04-28"
 [116] "2006-04-27" "2006-04-26" "2006-04-25" "2006-04-24" "2006-04-21"
 [121] "2006-04-20" "2006-04-19" "2006-04-18" "2006-04-13" "2006-04-12"
 [126] "2006-04-11" "2006-04-10" "2006-04-07" "2006-04-06" "2006-04-05"
 [131] "2006-04-04" "2006-04-03" "2006-03-31" "2006-03-30" "2006-03-29"
 [136] "2006-03-28" "2006-03-27" "2006-03-24" "2006-03-23" "2006-03-22"
 [141] "2006-03-21" "2006-03-20" "2006-03-17" "2006-03-16" "2006-03-15"
 [146] "2006-03-14" "2006-03-13" "2006-03-10" "2006-03-09" "2006-03-08"
 [151] "2006-03-07" "2006-03-06" "2006-03-03" "2006-03-02" "2006-03-01"
 [156] "2006-02-28" "2006-02-27" "2006-02-24" "2006-02-23" "2006-02-22"
 [161] "2006-02-21" "2006-02-20" "2006-02-17" "2006-02-16" "2006-02-15"
 [166] "2006-02-14" "2006-02-13" "2006-02-10" "2006-02-09" "2006-02-08"
 [171] "2006-02-07" "2006-02-06" "2006-02-03" "2006-02-02" "2006-02-01"
 [176] "2006-01-31" "2006-01-30" "2006-01-27" "2006-01-26" "2006-01-25"
 [181] "2006-01-24" "2006-01-23" "2006-01-20" "2006-01-19" "2006-01-18"
 [186] "2006-01-17" "2006-01-16" "2006-01-13" "2006-01-12" "2006-01-11"
 [191] "2006-01-10" "2006-01-09" "2006-01-06" "2006-01-05" "2006-01-04"
 [196] "2006-01-03" "2006-01-02" "2005-12-30" "2005-12-29" "2005-12-28"
 [201] "2005-12-27" "2005-12-23" "2005-12-22" "2005-12-21" "2005-12-20"
 [206] "2005-12-19" "2005-12-16" "2005-12-15" "2005-12-14" "2005-12-13"
 [211] "2005-12-12" "2005-12-09" "2005-12-08" "2005-12-07" "2005-12-06"
 [216] "2005-12-05" "2005-12-02" "2005-12-01" "2005-11-30" "2005-11-29"
 [221] "2005-11-28" "2005-11-25" "2005-11-24" "2005-11-23" "2005-11-22"
 [226] "2005-11-21" "2005-11-18" "2005-11-17" "2005-11-16" "2005-11-15"
 [231] "2005-11-14" "2005-11-11" "2005-11-10" "2005-11-09" "2005-11-08"
 [236] "2005-11-07" "2005-11-04" "2005-11-03" "2005-11-02" "2005-11-01"
 [241] "2005-10-31" "2005-10-28" "2005-10-27" "2005-10-26" "2005-10-25"
 [246] "2005-10-24" "2005-10-21" "2005-10-20" "2005-10-19" "2005-10-18"
 [251] "2005-10-17" "2005-10-14" "2005-10-13" "2005-10-12" "2005-10-11"
 [256] "2005-10-10" "2005-10-07" "2005-10-06" "2005-10-05" "2005-10-04"
 [261] "2005-10-03" "2005-09-30" "2005-09-29" "2005-09-28" "2005-09-27"
 [266] "2005-09-26" "2005-09-23" "2005-09-22" "2005-09-21" "2005-09-20"
 [271] "2005-09-19" "2005-09-16" "2005-09-15" "2005-09-14" "2005-09-13"
 [276] "2005-09-12" "2005-09-09" "2005-09-08" "2005-09-07" "2005-09-06"
 [281] "2005-09-05" "2005-09-02" "2005-09-01" "2005-08-31" "2005-08-30"
 [286] "2005-08-29" "2005-08-26" "2005-08-25" "2005-08-24" "2005-08-23"
 [291] "2005-08-22" "2005-08-19" "2005-08-18" "2005-08-17" "2005-08-16"
 [296] "2005-08-15" "2005-08-12" "2005-08-11" "2005-08-10" "2005-08-09"
 [301] "2005-08-08" "2005-08-05" "2005-08-04" "2005-08-03" "2005-08-02"
 [306] "2005-08-01" "2005-07-29" "2005-07-28" "2005-07-27" "2005-07-26"
 [311] "2005-07-25" "2005-07-22" "2005-07-21" "2005-07-20" "2005-07-19"
 [316] "2005-07-18" "2005-07-15" "2005-07-14" "2005-07-13" "2005-07-12"
 [321] "2005-07-11" "2005-07-08" "2005-07-07" "2005-07-06" "2005-07-05"
 [326] "2005-07-04" "2005-07-01" "2005-06-30" "2005-06-29" "2005-06-28"
 [331] "2005-06-27" "2005-06-24" "2005-06-23" "2005-06-22" "2005-06-21"
 [336] "2005-06-20" "2005-06-17" "2005-06-16" "2005-06-15" "2005-06-14"
 [341] "2005-06-13" "2005-06-10" "2005-06-09" "2005-06-08" "2005-06-07"
 [346] "2005-06-06" "2005-06-03" "2005-06-02" "2005-06-01" "2005-05-31"
 [351] "2005-05-30" "2005-05-27" "2005-05-26" "2005-05-25" "2005-05-24"
 [356] "2005-05-23" "2005-05-20" "2005-05-19" "2005-05-18" "2005-05-17"
 [361] "2005-05-16" "2005-05-13" "2005-05-12" "2005-05-11" "2005-05-10"
 [366] "2005-05-09" "2005-05-06" "2005-05-05" "2005-05-04" "2005-05-03"
 [371] "2005-05-02" "2005-04-29" "2005-04-28" "2005-04-27" "2005-04-26"
 [376] "2005-04-25" "2005-04-22" "2005-04-21" "2005-04-20" "2005-04-19"
 [381] "2005-04-18" "2005-04-15" "2005-04-14" "2005-04-13" "2005-04-12"
 [386] "2005-04-11" "2005-04-08" "2005-04-07" "2005-04-06" "2005-04-05"
 [391] "2005-04-04" "2005-04-01" "2005-03-31" "2005-03-30" "2005-03-29"
 [396] "2005-03-24" "2005-03-23" "2005-03-22" "2005-03-21" "2005-03-18"
 [401] "2005-03-17" "2005-03-16" "2005-03-15" "2005-03-14" "2005-03-11"
 [406] "2005-03-10" "2005-03-09" "2005-03-08" "2005-03-07" "2005-03-04"
 [411] "2005-03-03" "2005-03-02" "2005-03-01" "2005-02-28" "2005-02-25"
 [416] "2005-02-24" "2005-02-23" "2005-02-22" "2005-02-21" "2005-02-18"
 [421] "2005-02-17" "2005-02-16" "2005-02-15" "2005-02-14" "2005-02-11"
 [426] "2005-02-10" "2005-02-09" "2005-02-08" "2005-02-07" "2005-02-04"
 [431] "2005-02-03" "2005-02-02" "2005-02-01" "2005-01-31" "2005-01-28"
 [436] "2005-01-27" "2005-01-26" "2005-01-25" "2005-01-24" "2005-01-21"
 [441] "2005-01-20" "2005-01-19" "2005-01-18" "2005-01-17" "2005-01-14"
 [446] "2005-01-13" "2005-01-12" "2005-01-11" "2005-01-10" "2005-01-07"
 [451] "2005-01-06" "2005-01-05" "2005-01-04" "2005-01-03" "2004-12-31"
 [456] "2004-12-30" "2004-12-29" "2004-12-28" "2004-12-27" "2004-12-24"
 [461] "2004-12-23" "2004-12-22" "2004-12-21" "2004-12-20" "2004-12-17"
 [466] "2004-12-16" "2004-12-15" "2004-12-14" "2004-12-13" "2004-12-10"
 [471] "2004-12-09" "2004-12-08" "2004-12-07" "2004-12-06" "2004-12-03"
 [476] "2004-12-02" "2004-12-01" "2004-11-30" "2004-11-29" "2004-11-26"
 [481] "2004-11-25" "2004-11-24" "2004-11-23" "2004-11-22" "2004-11-19"
 [486] "2004-11-18" "2004-11-17" "2004-11-16" "2004-11-15" "2004-11-12"
 [491] "2004-11-11" "2004-11-10" "2004-11-09" "2004-11-08" "2004-11-05"
 [496] "2004-11-04" "2004-11-03" "2004-11-02" "2004-11-01" "2004-10-29"
 [501] "2004-10-28" "2004-10-27" "2004-10-26" "2004-10-25" "2004-10-22"
 [506] "2004-10-21" "2004-10-20" "2004-10-19" "2004-10-18" "2004-10-15"
 [511] "2004-10-14" "2004-10-13" "2004-10-12" "2004-10-11" "2004-10-08"
 [516] "2004-10-07" "2004-10-06" "2004-10-05" "2004-10-04" "2004-10-01"
 [521] "2004-09-30" "2004-09-29" "2004-09-28" "2004-09-27" "2004-09-24"
 [526] "2004-09-23" "2004-09-22" "2004-09-21" "2004-09-20" "2004-09-17"
 [531] "2004-09-16" "2004-09-15" "2004-09-14" "2004-09-13" "2004-09-10"
 [536] "2004-09-09" "2004-09-08" "2004-09-07" "2004-09-06" "2004-09-03"
 [541] "2004-09-02" "2004-09-01" "2004-08-31" "2004-08-30" "2004-08-27"
 [546] "2004-08-26" "2004-08-25" "2004-08-24" "2004-08-23" "2004-08-20"
 [551] "2004-08-19" "2004-08-18" "2004-08-17" "2004-08-16" "2004-08-13"
 [556] "2004-08-12" "2004-08-11" "2004-08-10" "2004-08-09" "2004-08-06"
 [561] "2004-08-05" "2004-08-04" "2004-08-03" "2004-08-02" "2004-07-30"
 [566] "2004-07-29" "2004-07-28" "2004-07-27" "2004-07-26" "2004-07-23"
 [571] "2004-07-22" "2004-07-21" "2004-07-20" "2004-07-19" "2004-07-16"
 [576] "2004-07-15" "2004-07-14" "2004-07-13" "2004-07-12" "2004-07-09"
 [581] "2004-07-08" "2004-07-07" "2004-07-06" "2004-07-05" "2004-07-02"
 [586] "2004-07-01" "2004-06-30" "2004-06-29" "2004-06-28" "2004-06-25"
 [591] "2004-06-24" "2004-06-23" "2004-06-22" "2004-06-21" "2004-06-18"
 [596] "2004-06-17" "2004-06-16" "2004-06-15" "2004-06-14" "2004-06-11"
 [601] "2004-06-10" "2004-06-09" "2004-06-08" "2004-06-07" "2004-06-04"
 [606] "2004-06-03" "2004-06-02" "2004-06-01" "2004-05-31" "2004-05-28"
 [611] "2004-05-27" "2004-05-26" "2004-05-25" "2004-05-24" "2004-05-21"
 [616] "2004-05-20" "2004-05-19" "2004-05-18" "2004-05-17" "2004-05-14"
 [621] "2004-05-13" "2004-05-12" "2004-05-11" "2004-05-10" "2004-05-07"
 [626] "2004-05-06" "2004-05-05" "2004-05-04" "2004-05-03" "2004-04-30"
 [631] "2004-04-29" "2004-04-28" "2004-04-27" "2004-04-26" "2004-04-23"
 [636] "2004-04-22" "2004-04-21" "2004-04-20" "2004-04-19" "2004-04-16"
 [641] "2004-04-15" "2004-04-14" "2004-04-13" "2004-04-08" "2004-04-07"
 [646] "2004-04-06" "2004-04-05" "2004-04-02" "2004-04-01" "2004-03-31"
 [651] "2004-03-30" "2004-03-29" "2004-03-26" "2004-03-25" "2004-03-24"
 [656] "2004-03-23" "2004-03-22" "2004-03-19" "2004-03-18" "2004-03-17"
 [661] "2004-03-16" "2004-03-15" "2004-03-12" "2004-03-11" "2004-03-10"
 [666] "2004-03-09" "2004-03-08" "2004-03-05" "2004-03-04" "2004-03-03"
 [671] "2004-03-02" "2004-03-01" "2004-02-27" "2004-02-26" "2004-02-25"
 [676] "2004-02-24" "2004-02-23" "2004-02-20" "2004-02-19" "2004-02-18"
 [681] "2004-02-17" "2004-02-16" "2004-02-13" "2004-02-12" "2004-02-11"
 [686] "2004-02-10" "2004-02-09" "2004-02-06" "2004-02-05" "2004-02-04"
 [691] "2004-02-03" "2004-02-02" "2004-01-30" "2004-01-29" "2004-01-28"
 [696] "2004-01-27" "2004-01-26" "2004-01-23" "2004-01-22" "2004-01-21"
 [701] "2004-01-20" "2004-01-19" "2004-01-16" "2004-01-15" "2004-01-14"
 [706] "2004-01-13" "2004-01-12" "2004-01-09" "2004-01-08" "2004-01-07"
 [711] "2004-01-06" "2004-01-05" "2004-01-02" "2003-12-31" "2003-12-30"
 [716] "2003-12-29" "2003-12-24" "2003-12-23" "2003-12-22" "2003-12-19"
 [721] "2003-12-18" "2003-12-17" "2003-12-16" "2003-12-15" "2003-12-12"
 [726] "2003-12-11" "2003-12-10" "2003-12-09" "2003-12-08" "2003-12-05"
 [731] "2003-12-04" "2003-12-03" "2003-12-02" "2003-12-01" "2003-11-28"
 [736] "2003-11-27" "2003-11-26" "2003-11-25" "2003-11-24" "2003-11-21"
 [741] "2003-11-20" "2003-11-19" "2003-11-18" "2003-11-17" "2003-11-14"
 [746] "2003-11-13" "2003-11-12" "2003-11-11" "2003-11-10" "2003-11-07"
 [751] "2003-11-06" "2003-11-05" "2003-11-04" "2003-11-03" "2003-10-31"
 [756] "2003-10-30" "2003-10-29" "2003-10-28" "2003-10-27" "2003-10-24"
 [761] "2003-10-23" "2003-10-22" "2003-10-21" "2003-10-20" "2003-10-17"
 [766] "2003-10-16" "2003-10-15" "2003-10-14" "2003-10-13" "2003-10-10"
 [771] "2003-10-09" "2003-10-08" "2003-10-07" "2003-10-06" "2003-10-03"
 [776] "2003-10-02" "2003-10-01" "2003-09-30" "2003-09-29" "2003-09-26"
 [781] "2003-09-25" "2003-09-24" "2003-09-23" "2003-09-22" "2003-09-19"
 [786] "2003-09-18" "2003-09-17" "2003-09-16" "2003-09-15" "2003-09-12"
 [791] "2003-09-11" "2003-09-10" "2003-09-09" "2003-09-08" "2003-09-05"
 [796] "2003-09-04" "2003-09-03" "2003-09-02" "2003-09-01" "2003-08-29"
 [801] "2003-08-28" "2003-08-27" "2003-08-26" "2003-08-25" "2003-08-22"
 [806] "2003-08-21" "2003-08-20" "2003-08-19" "2003-08-18" "2003-08-15"
 [811] "2003-08-14" "2003-08-13" "2003-08-12" "2003-08-11" "2003-08-08"
 [816] "2003-08-07" "2003-08-06" "2003-08-05" "2003-08-04" "2003-08-01"
 [821] "2003-07-31" "2003-07-30" "2003-07-29" "2003-07-28" "2003-07-25"
 [826] "2003-07-24" "2003-07-23" "2003-07-22" "2003-07-21" "2003-07-18"
 [831] "2003-07-17" "2003-07-16" "2003-07-15" "2003-07-14" "2003-07-11"
 [836] "2003-07-10" "2003-07-09" "2003-07-08" "2003-07-07" "2003-07-04"
 [841] "2003-07-03" "2003-07-02" "2003-07-01" "2003-06-30" "2003-06-27"
 [846] "2003-06-26" "2003-06-25" "2003-06-24" "2003-06-23" "2003-06-20"
 [851] "2003-06-19" "2003-06-18" "2003-06-17" "2003-06-16" "2003-06-13"
 [856] "2003-06-12" "2003-06-11" "2003-06-10" "2003-06-09" "2003-06-06"
 [861] "2003-06-05" "2003-06-04" "2003-06-03" "2003-06-02" "2003-05-30"
 [866] "2003-05-29" "2003-05-28" "2003-05-27" "2003-05-26" "2003-05-23"
 [871] "2003-05-22" "2003-05-21" "2003-05-20" "2003-05-19" "2003-05-16"
 [876] "2003-05-15" "2003-05-14" "2003-05-13" "2003-05-12" "2003-05-09"
 [881] "2003-05-08" "2003-05-07" "2003-05-06" "2003-05-05" "2003-05-02"
 [886] "2003-04-30" "2003-04-29" "2003-04-28" "2003-04-25" "2003-04-24"
 [891] "2003-04-23" "2003-04-22" "2003-04-17" "2003-04-16" "2003-04-15"
 [896] "2003-04-14" "2003-04-11" "2003-04-10" "2003-04-09" "2003-04-08"
 [901] "2003-04-07" "2003-04-04" "2003-04-03" "2003-04-02" "2003-04-01"
 [906] "2003-03-31" "2003-03-28" "2003-03-27" "2003-03-26" "2003-03-25"
 [911] "2003-03-24" "2003-03-21" "2003-03-20" "2003-03-19" "2003-03-18"
 [916] "2003-03-17" "2003-03-14" "2003-03-13" "2003-03-12" "2003-03-11"
 [921] "2003-03-10" "2003-03-07" "2003-03-06" "2003-03-05" "2003-03-04"
 [926] "2003-03-03" "2003-02-28" "2003-02-27" "2003-02-26" "2003-02-25"
 [931] "2003-02-24" "2003-02-21" "2003-02-20" "2003-02-19" "2003-02-18"
 [936] "2003-02-17" "2003-02-14" "2003-02-13" "2003-02-12" "2003-02-11"
 [941] "2003-02-10" "2003-02-07" "2003-02-06" "2003-02-05" "2003-02-04"
 [946] "2003-02-03" "2003-01-31" "2003-01-30" "2003-01-29" "2003-01-28"
 [951] "2003-01-27" "2003-01-24" "2003-01-23" "2003-01-22" "2003-01-21"
 [956] "2003-01-20" "2003-01-17" "2003-01-16" "2003-01-15" "2003-01-14"
 [961] "2003-01-13" "2003-01-10" "2003-01-09" "2003-01-08" "2003-01-07"
 [966] "2003-01-06" "2003-01-03" "2003-01-02" "2002-12-31" "2002-12-30"
 [971] "2002-12-27" "2002-12-24" "2002-12-23" "2002-12-20" "2002-12-19"
 [976] "2002-12-18" "2002-12-17" "2002-12-16" "2002-12-13" "2002-12-12"
 [981] "2002-12-11" "2002-12-10" "2002-12-09" "2002-12-06" "2002-12-05"
 [986] "2002-12-04" "2002-12-03" "2002-12-02" "2002-11-29" "2002-11-28"
 [991] "2002-11-27" "2002-11-26" "2002-11-25" "2002-11-22" "2002-11-21"
 [996] "2002-11-20" "2002-11-19" "2002-11-18" "2002-11-15" "2002-11-14"
[1001] "2002-11-13" "2002-11-12" "2002-11-11" "2002-11-08" "2002-11-07"
[1006] "2002-11-06" "2002-11-05" "2002-11-04" "2002-11-01" "2002-10-31"
[1011] "2002-10-30" "2002-10-29" "2002-10-28" "2002-10-25" "2002-10-24"
[1016] "2002-10-23" "2002-10-22" "2002-10-21" "2002-10-18" "2002-10-17"
[1021] "2002-10-16" "2002-10-15" "2002-10-14" "2002-10-11" "2002-10-10"
[1026] "2002-10-09" "2002-10-08" "2002-10-07" "2002-10-04" "2002-10-03"
[1031] "2002-10-02" "2002-10-01" "2002-09-30" "2002-09-27" "2002-09-26"
[1036] "2002-09-25" "2002-09-24" "2002-09-23" "2002-09-20" "2002-09-19"
[1041] "2002-09-18" "2002-09-17" "2002-09-16" "2002-09-13" "2002-09-12"
[1046] "2002-09-11" "2002-09-10" "2002-09-09" "2002-09-06" "2002-09-05"
[1051] "2002-09-04" "2002-09-03" "2002-09-02" "2002-08-30" "2002-08-29"
[1056] "2002-08-28" "2002-08-27" "2002-08-26" "2002-08-23" "2002-08-22"
[1061] "2002-08-21" "2002-08-20" "2002-08-19" "2002-08-16" "2002-08-15"
[1066] "2002-08-14" "2002-08-13" "2002-08-12" "2002-08-09" "2002-08-08"
[1071] "2002-08-07" "2002-08-06" "2002-08-05" "2002-08-02" "2002-08-01"
[1076] "2002-07-31" "2002-07-30" "2002-07-29" "2002-07-26" "2002-07-25"
[1081] "2002-07-24" "2002-07-23" "2002-07-22" "2002-07-19" "2002-07-18"
[1086] "2002-07-17" "2002-07-16" "2002-07-15" "2002-07-12" "2002-07-11"
[1091] "2002-07-10" "2002-07-09" "2002-07-08" "2002-07-05" "2002-07-04"
[1096] "2002-07-03" "2002-07-02" "2002-07-01" "2002-06-28" "2002-06-27"
[1101] "2002-06-26" "2002-06-25" "2002-06-24" "2002-06-21" "2002-06-20"
[1106] "2002-06-19" "2002-06-18" "2002-06-17" "2002-06-14" "2002-06-13"
[1111] "2002-06-12" "2002-06-11" "2002-06-10" "2002-06-07" "2002-06-06"
[1116] "2002-06-05" "2002-06-04" "2002-06-03" "2002-05-31" "2002-05-30"
[1121] "2002-05-29" "2002-05-28" "2002-05-27" "2002-05-24" "2002-05-23"
[1126] "2002-05-22" "2002-05-21" "2002-05-20" "2002-05-17" "2002-05-16"
[1131] "2002-05-15" "2002-05-14" "2002-05-13" "2002-05-10" "2002-05-09"
[1136] "2002-05-08" "2002-05-07" "2002-05-06" "2002-05-03" "2002-05-02"
[1141] "2002-04-30" "2002-04-29" "2002-04-26" "2002-04-25" "2002-04-24"
[1146] "2002-04-23" "2002-04-22" "2002-04-19" "2002-04-18" "2002-04-17"
[1151] "2002-04-16" "2002-04-15" "2002-04-12" "2002-04-11" "2002-04-10"
[1156] "2002-04-09" "2002-04-08" "2002-04-05" "2002-04-04" "2002-04-03"
[1161] "2002-04-02" "2002-03-28" "2002-03-27" "2002-03-26" "2002-03-25"
[1166] "2002-03-22" "2002-03-21" "2002-03-20" "2002-03-19" "2002-03-18"
[1171] "2002-03-15" "2002-03-14" "2002-03-13" "2002-03-12" "2002-03-11"
[1176] "2002-03-08" "2002-03-07" "2002-03-06" "2002-03-05" "2002-03-04"
[1181] "2002-03-01" "2002-02-28" "2002-02-27" "2002-02-26" "2002-02-25"
[1186] "2002-02-22" "2002-02-21" "2002-02-20" "2002-02-19" "2002-02-18"
[1191] "2002-02-15" "2002-02-14" "2002-02-13" "2002-02-12" "2002-02-11"
[1196] "2002-02-08" "2002-02-07" "2002-02-06" "2002-02-05" "2002-02-04"
[1201] "2002-02-01" "2002-01-31" "2002-01-30" "2002-01-29" "2002-01-28"
[1206] "2002-01-25" "2002-01-24" "2002-01-23" "2002-01-22" "2002-01-21"
[1211] "2002-01-18" "2002-01-17" "2002-01-16" "2002-01-15" "2002-01-14"
[1216] "2002-01-11" "2002-01-10" "2002-01-09" "2002-01-08" "2002-01-07"
[1221] "2002-01-04" "2002-01-03" "2002-01-02" "2001-12-28" "2001-12-27"
[1226] "2001-12-24" "2001-12-21" "2001-12-20" "2001-12-19" "2001-12-18"
[1231] "2001-12-17" "2001-12-14" "2001-12-13" "2001-12-12" "2001-12-11"
[1236] "2001-12-10" "2001-12-07" "2001-12-06" "2001-12-05" "2001-12-04"
[1241] "2001-12-03" "2001-11-30" "2001-11-29" "2001-11-28" "2001-11-27"
[1246] "2001-11-26" "2001-11-23" "2001-11-22" "2001-11-21" "2001-11-20"
[1251] "2001-11-19" "2001-11-16" "2001-11-15" "2001-11-14" "2001-11-13"
[1256] "2001-11-12" "2001-11-09" "2001-11-08" "2001-11-07" "2001-11-06"
[1261] "2001-11-05" "2001-11-02" "2001-11-01" "2001-10-31" "2001-10-30"
[1266] "2001-10-29" "2001-10-26" "2001-10-25" "2001-10-24" "2001-10-23"
[1271] "2001-10-22" "2001-10-19" "2001-10-18" "2001-10-17" "2001-10-16"
[1276] "2001-10-15" "2001-10-12" "2001-10-11" "2001-10-10" "2001-10-09"
[1281] "2001-10-08" "2001-10-05" "2001-10-04" "2001-10-03" "2001-10-02"
[1286] "2001-10-01" "2001-09-28" "2001-09-27" "2001-09-26" "2001-09-25"
[1291] "2001-09-24" "2001-09-21" "2001-09-20" "2001-09-19" "2001-09-18"
[1296] "2001-09-17" "2001-09-14" "2001-09-13" "2001-09-12" "2001-09-11"
[1301] "2001-09-10" "2001-09-07" "2001-09-06" "2001-09-05" "2001-09-04"
[1306] "2001-09-03" "2001-08-31" "2001-08-30" "2001-08-29" "2001-08-28"
[1311] "2001-08-27" "2001-08-24" "2001-08-23" "2001-08-22" "2001-08-21"
[1316] "2001-08-20" "2001-08-17" "2001-08-16" "2001-08-15" "2001-08-14"
[1321] "2001-08-13" "2001-08-10" "2001-08-09" "2001-08-08" "2001-08-07"
[1326] "2001-08-06" "2001-08-03" "2001-08-02" "2001-08-01" "2001-07-31"
[1331] "2001-07-30" "2001-07-27" "2001-07-26" "2001-07-25" "2001-07-24"
[1336] "2001-07-23" "2001-07-20" "2001-07-19" "2001-07-18" "2001-07-17"
[1341] "2001-07-16" "2001-07-13" "2001-07-12" "2001-07-11" "2001-07-10"
[1346] "2001-07-09" "2001-07-06" "2001-07-05" "2001-07-04" "2001-07-03"
[1351] "2001-07-02" "2001-06-29" "2001-06-28" "2001-06-27" "2001-06-26"
[1356] "2001-06-25" "2001-06-22" "2001-06-21" "2001-06-20" "2001-06-19"
[1361] "2001-06-18" "2001-06-15" "2001-06-14" "2001-06-13" "2001-06-12"
[1366] "2001-06-11" "2001-06-08" "2001-06-07" "2001-06-06" "2001-06-05"
[1371] "2001-06-04" "2001-06-01" "2001-05-31" "2001-05-30" "2001-05-29"
[1376] "2001-05-28" "2001-05-25" "2001-05-24" "2001-05-23" "2001-05-22"
[1381] "2001-05-21" "2001-05-18" "2001-05-17" "2001-05-16" "2001-05-15"
[1386] "2001-05-14" "2001-05-11" "2001-05-10" "2001-05-09" "2001-05-08"
[1391] "2001-05-07" "2001-05-04" "2001-05-03" "2001-05-02" "2001-04-30"
[1396] "2001-04-27" "2001-04-26" "2001-04-25" "2001-04-24" "2001-04-23"
[1401] "2001-04-20" "2001-04-19" "2001-04-18" "2001-04-17" "2001-04-12"
[1406] "2001-04-11" "2001-04-10" "2001-04-09" "2001-04-06" "2001-04-05"
[1411] "2001-04-04" "2001-04-03" "2001-04-02" "2001-03-30" "2001-03-29"
[1416] "2001-03-28" "2001-03-27" "2001-03-26" "2001-03-23" "2001-03-22"
[1421] "2001-03-21" "2001-03-20" "2001-03-19" "2001-03-16" "2001-03-15"
[1426] "2001-03-14" "2001-03-13" "2001-03-12" "2001-03-09" "2001-03-08"
[1431] "2001-03-07" "2001-03-06" "2001-03-05" "2001-03-02" "2001-03-01"
[1436] "2001-02-28" "2001-02-27" "2001-02-26" "2001-02-23" "2001-02-22"
[1441] "2001-02-21" "2001-02-20" "2001-02-19" "2001-02-16" "2001-02-15"
[1446] "2001-02-14" "2001-02-13" "2001-02-12" "2001-02-09" "2001-02-08"
[1451] "2001-02-07" "2001-02-06" "2001-02-05" "2001-02-02" "2001-02-01"
[1456] "2001-01-31" "2001-01-30" "2001-01-29" "2001-01-26" "2001-01-25"
[1461] "2001-01-24" "2001-01-23" "2001-01-22" "2001-01-19" "2001-01-18"
[1466] "2001-01-17" "2001-01-16" "2001-01-15" "2001-01-12" "2001-01-11"
[1471] "2001-01-10" "2001-01-09" "2001-01-08" "2001-01-05" "2001-01-04"
[1476] "2001-01-03" "2001-01-02" "2000-12-29" "2000-12-28" "2000-12-27"
[1481] "2000-12-22" "2000-12-21" "2000-12-20" "2000-12-19" "2000-12-18"
[1486] "2000-12-15" "2000-12-14" "2000-12-13" "2000-12-12" "2000-12-11"
[1491] "2000-12-08" "2000-12-07" "2000-12-06" "2000-12-05" "2000-12-04"
[1496] "2000-12-01" "2000-11-30" "2000-11-29" "2000-11-28" "2000-11-27"
[1501] "2000-11-24" "2000-11-23" "2000-11-22" "2000-11-21" "2000-11-20"
[1506] "2000-11-17" "2000-11-16" "2000-11-15" "2000-11-14" "2000-11-13"
[1511] "2000-11-10" "2000-11-09" "2000-11-08" "2000-11-07" "2000-11-06"
[1516] "2000-11-03" "2000-11-02" "2000-11-01" "2000-10-31" "2000-10-30"
[1521] "2000-10-27" "2000-10-26" "2000-10-25" "2000-10-24" "2000-10-23"
[1526] "2000-10-20" "2000-10-19" "2000-10-18" "2000-10-17" "2000-10-16"
[1531] "2000-10-13" "2000-10-12" "2000-10-11" "2000-10-10" "2000-10-09"
[1536] "2000-10-06" "2000-10-05" "2000-10-04" "2000-10-03" "2000-10-02"
[1541] "2000-09-29" "2000-09-28" "2000-09-27" "2000-09-26" "2000-09-25"
[1546] "2000-09-22" "2000-09-21" "2000-09-20" "2000-09-19" "2000-09-18"
[1551] "2000-09-15" "2000-09-14" "2000-09-13" "2000-09-12" "2000-09-11"
[1556] "2000-09-08" "2000-09-07" "2000-09-06" "2000-09-05" "2000-09-04"
[1561] "2000-09-01" "2000-08-31" "2000-08-30" "2000-08-29" "2000-08-28"
[1566] "2000-08-25" "2000-08-24" "2000-08-23" "2000-08-22" "2000-08-21"
[1571] "2000-08-18" "2000-08-17" "2000-08-16" "2000-08-15" "2000-08-14"
[1576] "2000-08-11" "2000-08-10" "2000-08-09" "2000-08-08" "2000-08-07"
[1581] "2000-08-04" "2000-08-03" "2000-08-02" "2000-08-01" "2000-07-31"
[1586] "2000-07-28" "2000-07-27" "2000-07-26" "2000-07-25" "2000-07-24"
[1591] "2000-07-21" "2000-07-20" "2000-07-19" "2000-07-18" "2000-07-17"
[1596] "2000-07-14" "2000-07-13" "2000-07-12" "2000-07-11" "2000-07-10"
[1601] "2000-07-07" "2000-07-06" "2000-07-05" "2000-07-04" "2000-07-03"
[1606] "2000-06-30" "2000-06-29" "2000-06-28" "2000-06-27" "2000-06-26"
[1611] "2000-06-23" "2000-06-22" "2000-06-21" "2000-06-20" "2000-06-19"
[1616] "2000-06-16" "2000-06-15" "2000-06-14" "2000-06-13" "2000-06-12"
[1621] "2000-06-09" "2000-06-08" "2000-06-07" "2000-06-06" "2000-06-05"
[1626] "2000-06-02" "2000-06-01" "2000-05-31" "2000-05-30" "2000-05-29"
[1631] "2000-05-26" "2000-05-25" "2000-05-24" "2000-05-23" "2000-05-22"
[1636] "2000-05-19" "2000-05-18" "2000-05-17" "2000-05-16" "2000-05-15"
[1641] "2000-05-12" "2000-05-11" "2000-05-10" "2000-05-09" "2000-05-08"
[1646] "2000-05-05" "2000-05-04" "2000-05-03" "2000-05-02" "2000-04-28"
[1651] "2000-04-27" "2000-04-26" "2000-04-25" "2000-04-20" "2000-04-19"
[1656] "2000-04-18" "2000-04-17" "2000-04-14" "2000-04-13" "2000-04-12"
[1661] "2000-04-11" "2000-04-10" "2000-04-07" "2000-04-06" "2000-04-05"
[1666] "2000-04-04" "2000-04-03" "2000-03-31" "2000-03-30" "2000-03-29"
[1671] "2000-03-28" "2000-03-27" "2000-03-24" "2000-03-23" "2000-03-22"
[1676] "2000-03-21" "2000-03-20" "2000-03-17" "2000-03-16" "2000-03-15"
[1681] "2000-03-14" "2000-03-13" "2000-03-10" "2000-03-09" "2000-03-08"
[1686] "2000-03-07" "2000-03-06" "2000-03-03" "2000-03-02" "2000-03-01"
[1691] "2000-02-29" "2000-02-28" "2000-02-25" "2000-02-24" "2000-02-23"
[1696] "2000-02-22" "2000-02-21" "2000-02-18" "2000-02-17" "2000-02-16"
[1701] "2000-02-15" "2000-02-14" "2000-02-11" "2000-02-10" "2000-02-09"
[1706] "2000-02-08" "2000-02-07" "2000-02-04" "2000-02-03" "2000-02-02"
[1711] "2000-02-01" "2000-01-31" "2000-01-28" "2000-01-27" "2000-01-26"
[1716] "2000-01-25" "2000-01-24" "2000-01-21" "2000-01-20" "2000-01-19"
[1721] "2000-01-18" "2000-01-17" "2000-01-14" "2000-01-13" "2000-01-12"
[1726] "2000-01-11" "2000-01-10" "2000-01-07" "2000-01-06" "2000-01-05"
[1731] "2000-01-04" "2000-01-03" "1999-12-30" "1999-12-29" "1999-12-28"
[1736] "1999-12-27" "1999-12-24" "1999-12-23" "1999-12-22" "1999-12-21"
[1741] "1999-12-20" "1999-12-17" "1999-12-16" "1999-12-15" "1999-12-14"
[1746] "1999-12-13" "1999-12-10" "1999-12-09" "1999-12-08" "1999-12-07"
[1751] "1999-12-06" "1999-12-03" "1999-12-02" "1999-12-01" "1999-11-30"
[1756] "1999-11-29" "1999-11-26" "1999-11-25" "1999-11-24" "1999-11-23"
[1761] "1999-11-22" "1999-11-19" "1999-11-18" "1999-11-17" "1999-11-16"
[1766] "1999-11-15" "1999-11-12" "1999-11-11" "1999-11-10" "1999-11-09"
[1771] "1999-11-08" "1999-11-05" "1999-11-04" "1999-11-03" "1999-11-02"
[1776] "1999-11-01" "1999-10-29" "1999-10-28" "1999-10-27" "1999-10-26"
[1781] "1999-10-25" "1999-10-22" "1999-10-21" "1999-10-20" "1999-10-19"
[1786] "1999-10-18" "1999-10-15" "1999-10-14" "1999-10-13" "1999-10-12"
[1791] "1999-10-11" "1999-10-08" "1999-10-07" "1999-10-06" "1999-10-05"
[1796] "1999-10-04" "1999-10-01" "1999-09-30" "1999-09-29" "1999-09-28"
[1801] "1999-09-27" "1999-09-24" "1999-09-23" "1999-09-22" "1999-09-21"
[1806] "1999-09-20" "1999-09-17" "1999-09-16" "1999-09-15" "1999-09-14"
[1811] "1999-09-13" "1999-09-10" "1999-09-09" "1999-09-08" "1999-09-07"
[1816] "1999-09-06" "1999-09-03" "1999-09-02" "1999-09-01" "1999-08-31"
[1821] "1999-08-30" "1999-08-27" "1999-08-26" "1999-08-25" "1999-08-24"
[1826] "1999-08-23" "1999-08-20" "1999-08-19" "1999-08-18" "1999-08-17"
[1831] "1999-08-16" "1999-08-13" "1999-08-12" "1999-08-11" "1999-08-10"
[1836] "1999-08-09" "1999-08-06" "1999-08-05" "1999-08-04" "1999-08-03"
[1841] "1999-08-02" "1999-07-30" "1999-07-29" "1999-07-28" "1999-07-27"
[1846] "1999-07-26" "1999-07-23" "1999-07-22" "1999-07-21" "1999-07-20"
[1851] "1999-07-19" "1999-07-16" "1999-07-15" "1999-07-14" "1999-07-13"
[1856] "1999-07-12" "1999-07-09" "1999-07-08" "1999-07-07" "1999-07-06"
[1861] "1999-07-05" "1999-07-02" "1999-07-01" "1999-06-30" "1999-06-29"
[1866] "1999-06-28" "1999-06-25" "1999-06-24" "1999-06-23" "1999-06-22"
[1871] "1999-06-21" "1999-06-18" "1999-06-17" "1999-06-16" "1999-06-15"
[1876] "1999-06-14" "1999-06-11" "1999-06-10" "1999-06-09" "1999-06-08"
[1881] "1999-06-07" "1999-06-04" "1999-06-03" "1999-06-02" "1999-06-01"
[1886] "1999-05-31" "1999-05-28" "1999-05-27" "1999-05-26" "1999-05-25"
[1891] "1999-05-24" "1999-05-21" "1999-05-20" "1999-05-19" "1999-05-18"
[1896] "1999-05-17" "1999-05-14" "1999-05-13" "1999-05-12" "1999-05-11"
[1901] "1999-05-10" "1999-05-07" "1999-05-06" "1999-05-05" "1999-05-04"
[1906] "1999-05-03" "1999-04-30" "1999-04-29" "1999-04-28" "1999-04-27"
[1911] "1999-04-26" "1999-04-23" "1999-04-22" "1999-04-21" "1999-04-20"
[1916] "1999-04-19" "1999-04-16" "1999-04-15" "1999-04-14" "1999-04-13"
[1921] "1999-04-12" "1999-04-09" "1999-04-08" "1999-04-07" "1999-04-06"
[1926] "1999-04-05" "1999-04-02" "1999-04-01" "1999-03-31" "1999-03-30"
[1931] "1999-03-29" "1999-03-26" "1999-03-25" "1999-03-24" "1999-03-23"
[1936] "1999-03-22" "1999-03-19" "1999-03-18" "1999-03-17" "1999-03-16"
[1941] "1999-03-15" "1999-03-12" "1999-03-11" "1999-03-10" "1999-03-09"
[1946] "1999-03-08" "1999-03-05" "1999-03-04" "1999-03-03" "1999-03-02"
[1951] "1999-03-01" "1999-02-26" "1999-02-25" "1999-02-24" "1999-02-23"
[1956] "1999-02-22" "1999-02-19" "1999-02-18" "1999-02-17" "1999-02-16"
[1961] "1999-02-15" "1999-02-12" "1999-02-11" "1999-02-10" "1999-02-09"
[1966] "1999-02-08" "1999-02-05" "1999-02-04" "1999-02-03" "1999-02-02"
[1971] "1999-02-01" "1999-01-29" "1999-01-28" "1999-01-27" "1999-01-26"
[1976] "1999-01-25" "1999-01-22" "1999-01-21" "1999-01-20" "1999-01-19"
[1981] "1999-01-18" "1999-01-15" "1999-01-14" "1999-01-13" "1999-01-12"
[1986] "1999-01-11" "1999-01-08" "1999-01-07" "1999-01-06" "1999-01-05"
[1991] "1999-01-04"
> 
> 
>    #  Using xpathApply, we can do
>  rates = xpathApply(doc, "//ns:Cube[@currency='SIT']", xmlGetAttr, "rate", namespaces = namespaces )
>  rates = as.numeric(unlist(rates))
> 
>    # Using an expression rather than  a function and ...
>  rates = xpathApply(doc, "//ns:Cube[@currency='SIT']", quote(xmlGetAttr(x, "rate")), namespaces = namespaces )
> 
>  #free(doc)
> 
>    #
>   uri = system.file("exampleData", "namespaces.xml", package = "XML")
>   d = xmlParse(uri)
>   getNodeSet(d, "//c:c", c(c="http://www.c.org"))
[[1]]
<c:c xmlns:c="http://www.c.org"/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>   getNodeSet(d, "/o:a//c:c", c("o" = "http://www.omegahat.org", "c" = "http://www.c.org"))
[[1]]
<c:c xmlns:c="http://www.c.org"/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>    # since http://www.omegahat.org is the default namespace, we can
>    # just the prefix "o" to map to that.
>   getNodeSet(d, "/o:a//c:c", c("o", "c" = "http://www.c.org"))
Warning: using o as prefix for default namespace http://www.omegahat.org
[[1]]
<c:c xmlns:c="http://www.c.org"/> 

attr(,"class")
[1] "XMLNodeSet"
> 
> 
>    # the following, perhaps unexpectedly but correctly, returns an empty
>    # with no matches
>    
>   getNodeSet(d, "//defaultNs", "http://www.omegahat.org")
list()
attr(,"class")
[1] "XMLNodeSet"
> 
>    # But if we create our own prefix for the evaluation of the XPath
>    # expression and use this in the expression, things work as one
>    # might hope.
>   getNodeSet(d, "//dummy:defaultNs", c(dummy = "http://www.omegahat.org"))
[[1]]
<defaultNs/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>    # And since the default value for the namespaces argument is the
>    # default namespace of the document, we can refer to it with our own
>    # prefix given as 
>   getNodeSet(d, "//d:defaultNs", "d")
[[1]]
<defaultNs/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>    # And the syntactic sugar is 
>   d["//d:defaultNs", namespace = "d"]
[[1]]
<defaultNs/> 

attr(,"class")
[1] "XMLNodeSet"
> 
> 
>    # this illustrates how we can use the prefixes in the XML document
>    # in our query and let getNodeSet() and friends map them to the
>    # actual namespace definitions.
>    # "o" is used to represent the default namespace for the document
>    # i.e. http://www.omegahat.org, and "r" is mapped to the same
>    # definition that has the prefix "r" in the XML document.
> 
>   tmp = getNodeSet(d, "/o:a/r:b/o:defaultNs", c("o", "r"))
Warning: using o as prefix for default namespace http://www.omegahat.org
>   xmlName(tmp[[1]])
[1] "defaultNs"
> 
> 
>   #free(d)
> 
> 
>    # Work with the nodes and their content (not just attributes) from the node set.
>    # From bondsTables.R in examples/
> 
>   doc = htmlTreeParse("http://finance.yahoo.com/bonds/composite_bond_rates", useInternalNodes = TRUE)
>   if(is.null(xmlRoot(doc))) 
+      doc = htmlTreeParse("http://finance.yahoo.com/bonds", useInternalNodes = TRUE)
> 
>      # Use XPath expression to find the nodes 
>      #  <div><table class="yfirttbl">..
>      # as these are the ones we want.
> 
>   if(!is.null(xmlRoot(doc))) {
+ 
+    o = getNodeSet(doc, "//div/table[@class='yfirttbl']")
+ 
+     # Write a function that will extract the information out of a given table node.
+    readHTMLTable =
+    function(tb)
+     {
+           # get the header information.
+       colNames = sapply(tb[["thead"]][["tr"]]["th"], xmlValue)
+       vals = sapply(tb[["tbody"]]["tr"],  function(x) sapply(x["td"], xmlValue))
+       matrix(as.numeric(vals[-1,]),
+               nrow = ncol(vals),
+               dimnames = list(vals[1,], colNames[-1]),
+               byrow = TRUE
+             )
+     }  
+ 
+ 
+      # Now process each of the table nodes in the o list.
+     tables = lapply(o, readHTMLTable)
+     names(tables) = lapply(o, function(x) xmlValue(x[["caption"]]))
+   }
> 
> 
>      # this illustrates an approach to doing queries on a sub tree
>      # within the document.
>      # Note that there is a memory leak incurred here as we create a new
>      # XMLInternalDocument in the getNodeSet().
> 
>     f = system.file("exampleData", "book.xml", package = "XML")
>     doc = xmlParse(f)
>     ch = getNodeSet(doc, "//chapter")
>     xpathApply(ch[[2]], "//section/title", xmlValue)
[[1]]
[1] "The elements of an XML document"

[[2]]
[1] "Parsing XML"

[[3]]
[1] "DOM"

[[4]]
[1] "SAX"

[[5]]
[1] "templates"

[[6]]
[1] "XPath expressions"

[[7]]
[1] "named templates"

> 
>       # To fix the memory leak, we explicitly create a new document for
>       # the subtree, perform the query and then free it _when_ we are done
>       # with the resulting nodes.
>     subDoc = xmlDoc(ch[[2]])
>     xpathApply(subDoc, "//section/title", xmlValue)
[[1]]
[1] "templates"

[[2]]
[1] "XPath expressions"

[[3]]
[1] "named templates"

>     free(subDoc)
> 
> 
>     txt = '<top xmlns="http://www.r-project.org" xmlns:r="http://www.r-project.org"><r:a><b/></r:a></top>'
>     doc = xmlInternalTreeParse(txt, asText = TRUE)
> 
> ## Not run: 
> ##D      # Will fail because it doesn't know what the namespace x is
> ##D      # and we have to have one eventhough it has no prefix in the document.
> ##D     xpathApply(doc, "//x:b")
> ## End(Not run)    
>       # So this is how we do it - just  say x is to be mapped to the
>       # default unprefixed namespace which we shall call x!
>     xpathApply(doc, "//x:b", namespaces = "x")
[[1]]
<b/> 

attr(,"class")
[1] "XMLNodeSet"
> 
>        # Here r is mapped to the the corresponding definition in the document.
>     xpathApply(doc, "//r:a", namespaces = "r")
[[1]]
<r:a>
  <b/>
</r:a> 

attr(,"class")
[1] "XMLNodeSet"
>        # Here, xpathApply figures this out for us, but will raise a warning.
>     xpathApply(doc, "//r:a")
[[1]]
<r:a>
  <b/>
</r:a> 

attr(,"class")
[1] "XMLNodeSet"
> 
>        # And here we use our own binding.
>     xpathApply(doc, "//x:a", namespaces = c(x = "http://www.r-project.org"))
[[1]]
<r:a>
  <b/>
</r:a> 

attr(,"class")
[1] "XMLNodeSet"
> 
> 
> 
>        # Get all the nodes in the entire tree.
>     table(unlist(sapply(doc["//*|//text()|//comment()|//processing-instruction()"],
+     class)))

       XMLAbstractNode XMLInternalElementNode        XMLInternalNode 
                     3                      3                      3 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("getXMLErrors")
> ### * getXMLErrors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getXMLErrors
> ### Title: Get XML/HTML document parse errors
> ### Aliases: getXMLErrors
> ### Keywords: IO programming
> 
> ### ** Examples
> 
>      # Get the "errors" in the HTML that was generated from this Rd file
>   getXMLErrors(system.file("html", "getXMLErrors.html", package = "XML"))
list()
attr(,"class")
[1] "XMLStructuredErrorList"
> 
> ## Not run: 
> ##D   getXMLErrors("http://www.omegahat.org/index.html")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("isXMLString")
> ### * isXMLString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isXMLString
> ### Title: Facilities for working with XML strings
> ### Aliases: isXMLString xml xmlParseString XMLString-class
> ### Keywords: IO
> 
> ### ** Examples
> 
>  isXMLString("a regular string < 20 characters long")
[1] FALSE
>  isXMLString("<a><b>c</b></a>")
[1] TRUE
> 
>  xmlParseString("<a><b>c</b></a>")
<a>
  <b>c</b>
</a> 
> 
>   # We can lie!
>  isXMLString(xml("foo"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("length.XMLNode")
> ### * length.XMLNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length.XMLNode
> ### Title: Determine the number of children in an XMLNode object.
> ### Aliases: length.XMLNode
> ### Keywords: file
> 
> ### ** Examples
> 
>   doc <- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
>   r <- xmlRoot(doc, skip=TRUE)
>   length(r)
[1] 33
>     # get the last entry
>   r[[length(r)]]
<record id="Volvo 142E">21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</record>
> 
> 
> 
> cleanEx()
> nameEx("libxmlVersion")
> ### * libxmlVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: libxmlVersion
> ### Title: Query the version and available features of the libxml library.
> ### Aliases: libxmlVersion libxmlFeatures
> ### Keywords: IO
> 
> ### ** Examples
> 
>  ver <- libxmlVersion()
>  if(is.null(ver)) {
+    cat("Relly old version of libxml\n")
+  } else {
+    if(ver$major > 1) {
+      cat("Using libxml2\n")
+    }
+  }
Using libxml2
> 
> 
> 
> cleanEx()
> nameEx("names.XMLNode")
> ### * names.XMLNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: names.XMLNode
> ### Title: Get the names of an XML nodes children.
> ### Aliases: names.XMLNode
> ### Keywords: file
> 
> ### ** Examples
> 
>  doc <- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
>  names(xmlRoot(doc))
  variables      record      record      record      record      record 
"variables"    "record"    "record"    "record"    "record"    "record" 
     record      record      record      record      record      record 
   "record"    "record"    "record"    "record"    "record"    "record" 
     record      record      record      record      record      record 
   "record"    "record"    "record"    "record"    "record"    "record" 
     record      record      record      record      record      record 
   "record"    "record"    "record"    "record"    "record"    "record" 
     record      record      record      record      record      record 
   "record"    "record"    "record"    "record"    "record"    "record" 
     record      record      record 
   "record"    "record"    "record" 
> 
>  r <- xmlRoot(doc)
>  r[names(r) == "variables"]
$variables
<variables count="11">
 <variable unit="Miles/gallon">mpg</variable>
 <variable>cyl</variable>
 <variable>disp</variable>
 <variable>hp</variable>
 <variable>drat</variable>
 <variable>wt</variable>
 <variable>qsec</variable>
 <variable>vs</variable>
 <variable type="FactorVariable" levels="automatic,manual">am</variable>
 <variable>gear</variable>
 <variable>carb</variable>
</variables>

attr(,"class")
[1] "XMLNodeList"
> 
> 
> 
> cleanEx()
> nameEx("newXMLDoc")
> ### * newXMLDoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newXMLDoc
> ### Title: Create internal XML node or document object
> ### Aliases: newXMLDoc newXMLNode newXMLPINode newXMLCDataNode
> ###   newXMLCommentNode newXMLTextNode newXMLDTDNode xmlDoc
> ###   coerce,vector,XMLInternalNode-method
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
> doc = newXMLDoc()
> 
>  # Simple creation of an XML tree using these functions
> top = newXMLNode("a")
> newXMLNode("b", attrs = c(x = 1, y = 'abc'), parent = top)
<b x="1" y="abc"/> 
> newXMLNode("c", "With some text", parent = top)
<c>With some text</c> 
> d = newXMLNode("d", newXMLTextNode("With text as an explicit node"), parent = top)
> newXMLCDataNode("x <- 1\n x > 2", parent = d)
<![CDATA[x <- 1
 x > 2]]> 
> 
> newXMLPINode("R", "library(XML)", top)
<?R library(XML)?> 
> newXMLCommentNode("This is a comment", parent = top)
<!--This is a comment--> 
> 
> o = newXMLNode("ol", parent = top)
> 
> kids = lapply(letters[1:3],
+                function(x)
+                   newXMLNode("li", x))
> addChildren(o, kids)
<ol>
  <li>a</li>
  <li>b</li>
  <li>c</li>
</ol> 
> 
> cat(saveXML(top))
<a>
  <b x="1" y="abc"/>
  <c>With some text</c>
  <d>With text as an explicit node<![CDATA[x <- 1
 x > 2]]></d>
  <?R library(XML)?>
  <!--This is a comment-->
  <ol>
    <li>a</li>
    <li>b</li>
    <li>c</li>
  </ol>
</a>> 
> 
> x = newXMLNode("block", "xyz", attrs = c(id = "bob"),
+                       namespace = "fo",
+                       namespaceDefinitions = c("fo" = "http://www.fo.org"))
> 
> xmlName(x, TRUE) == "fo"
[1] FALSE
> 
>   # a short cut to define a name space and make it the prefix for the
>   # node, thus avoiding repeating the prefix via the namespace argument.
> x = newXMLNode("block", "xyz", attrs = c(id = "bob"),
+                       namespace = c("fo" = "http://www.fo.org"))
> 
> 
>  # name space on the attribute
> x = newXMLNode("block", attrs = c("fo:id" = "bob"),
+                       namespaceDefinitions = c("fo" = "http://www.fo.org"))
> 
> 
> 
> 
> x = summary(rnorm(1000))
> d = xmlTree()
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> d$addNode("table", close = FALSE)
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
> 
> d$addNode("tr", .children = sapply(names(x), function(x) d$addNode("th", x)))
> d$addNode("tr", .children = sapply(x, function(x) d$addNode("td", format(x))))
> 
> d$closeNode()
> 
> 
> # Just doctype
> z = xmlTree("people", dtd = "people")
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> # no public element
> z = xmlTree("people", dtd = c("people", "", "http://www.omegahat.org/XML/types.dtd"))
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> # public and system
> z = xmlTree("people", dtd = c("people", "//a//b//c//d", "http://www.omegahat.org/XML/types.dtd"))
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> 
> # Using a DTD node directly.
> dtd = newXMLDTDNode(c("people", "", "http://www.omegahat.org/XML/types.dtd"))
> z = xmlTree("people", dtd = dtd)
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> 
> 
> x = rnorm(3)
> z = xmlTree("r:data", namespaces = c(r = "http://www.r-project.org"))
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$addNode("numeric", attrs = c("r:length" = length(x)), close = FALSE)
> lapply(x, function(v) z$addNode("el", x))
[[1]]
<el>1.13496508865819</el> 

[[2]]
<el>1.13496508865819</el> 

[[3]]
<el>1.13496508865819</el> 

> z$closeNode()
> # should give   <r:data><numeric r:length="3"/></r:data>
> 
> 
> # shows namespace prefix on an attribute, and different from the one on the node.
> z = xmlTree()
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$addNode("r:data",  namespace = c(r = "http://www.r-project.org", omg = "http://www.omegahat.org"), close = FALSE)
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
> x = rnorm(3)
> z$addNode("r:numeric", attrs = c("omg:length" = length(x)))
> 
> 
> z = xmlTree("people", namespaces = list(r = "http://www.r-project.org"))
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$setNamespace("r")
> 
> z$addNode("person", attrs = c(id = "123"), close = FALSE)
> z$addNode("firstname", "Duncan")
> z$addNode("surname", "Temple Lang")
> z$addNode("title", "Associate Professor")
> z$addNode("expertize", close = FALSE)
> z$addNode("topic", "Data Technologies")
> z$addNode("topic", "Programming Language Design")
> z$addNode("topic", "Parallel Computing")
> z$addNode("topic", "Data Visualization")
> z$closeTag()
> z$addNode("address", "4210 Mathematical Sciences Building, UC Davis")
> 
> 
> 
>    # 
> txt = newXMLTextNode("x &lt; 1")
> txt # okay
x &lt; 1 
> saveXML(txt) # x &amp;lt; 1
[1] "x &amp;lt; 1"
> 
>    # By escaping the text, we ensure the entities don't
>    # get expanded, i.e. &lt; doesn't become &amp;lt;
> txt = newXMLTextNode(I("x &lt; 1"))
> txt # okay
x &lt; 1 
> saveXML(txt) # x &amp;lt; 1
[1] "x &lt; 1"
> 
> 
> newXMLNode("r:expr", newXMLTextNode(I("x < 1")),
+             namespaceDefinitions = c(r = "http://www.r-project.org"))
<r:expr xmlns:r="http://www.r-project.org">x &lt; 1</r:expr> 
> 
> 
> 
> 
> cleanEx()
> nameEx("parseDTD")
> ### * parseDTD
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parseDTD
> ### Title: Read a Document Type Definition (DTD)
> ### Aliases: parseDTD
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData", "foo.dtd",package="XML")
>  parseDTD(dtdFile)
$elements
$elements$tmp
$name
[1] "tmp"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$variables
$name
[1] "variables"

$type
element 
     15 

$contents
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "variable"

attr(,"class")
[1] "XMLElementContent"

$attributes
$attributes$count
$name
[1] "count"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"


attr(,"class")
[1] "XMLElementDef"

$elements$record
$name
[1] "record"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
$attributes$id
$name
[1] "id"

$type
CDATA 
   16 

$defaultType
Required 
       2 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"


attr(,"class")
[1] "XMLElementDef"

$elements$variable
$name
[1] "variable"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
$attributes$type
$name
[1] "type"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$attributes$unit
$name
[1] "unit"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$attributes$levels
$name
[1] "levels"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"


attr(,"class")
[1] "XMLElementDef"

$elements$dataset
$name
[1] "dataset"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Or 
 4 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLOrContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
$attributes$name
$name
[1] "name"

$type
CDATA 
   16 

$defaultType
Required 
       2 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$attributes$source
$name
[1] "source"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"

$attributes$numRecords
$name
[1] "numRecords"

$type
CDATA 
   16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"


attr(,"class")
[1] "XMLElementDef"

$elements$entry0
$name
[1] "entry0"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Or 
 4 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"


attr(,"class")
[1] "XMLOrContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Or 
 4 

$ocur
Mult 
   3 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variable"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLOrContent"

$elements[[4]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "foo"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$entry1
$name
[1] "entry1"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Or 
 4 

$ocur
Mult 
   3 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variable"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLOrContent"

$elements[[4]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "foo"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$entry2
$name
[1] "entry2"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Sequence 
       3 

$ocur
Mult 
   3 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variable"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$elements[[4]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "foo"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$entry3
$name
[1] "entry3"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Or 
 4 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"


attr(,"class")
[1] "XMLOrContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "a"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "b"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "c"

attr(,"class")
[1] "XMLElementContent"

$elements[[4]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "d"

attr(,"class")
[1] "XMLElementContent"

$elements[[5]]
$type
Or 
 4 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "e"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "f"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLOrContent"


attr(,"class")
[1] "XMLSequenceContent"

$elements[[4]]
$type
Element 
      2 

$ocur
One or More 
          4 

$elements
[1] "foo"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$entry
$name
[1] "entry"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "variables"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "record"

attr(,"class")
[1] "XMLElementContent"

$elements[[3]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "tmp"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
$attributes$a
$name
[1] "a"

$type
CDATA 
   16 

$defaultType
Fixed 
    4 

$defaultValue
[1] "fixed a"

attr(,"class")
[1] "XMLAttributeDef"

$attributes$c
$name
[1] "c"

$type
Enumeration 
         16 

$defaultType
Implied 
      3 

$defaultValue
[1] ""

attr(,"class")
[1] "XMLAttributeDef"


attr(,"class")
[1] "XMLElementDef"


$entities
$entities$foobar
$name
[1] "foobar"

$value
[1] "xxx"

$original
[1] "xxx"

attr(,"class")
[1] "XMLEntity"

$entities$outside
$name
[1] "outside"

$value
[1] "entityValue"

$original
NULL

attr(,"class")
[1] "XMLSystemEntity"


attr(,"class")
[1] "ExternalDTD"
> 
> txt <- readLines(dtdFile)
> txt <- paste(txt,  collapse="\n")
> d <- parseDTD(txt, asText=TRUE)
> 
> 
> ## Not run: 
> ##D  url <- "http://www.omegahat.org/XML/DTDs/DatasetByRecord.dtd"
> ##D  d <- parseDTD(url, asText=FALSE)  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("parseURI")
> ### * parseURI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parseURI
> ### Title: Parse a URI string into its elements
> ### Aliases: parseURI URI-class coerce,URI,character-method
> ### Keywords: IO
> 
> ### ** Examples
> 
>   parseURI("http://www.omegahat.org:8080/RCurl/index.html")
$scheme
[1] "http"

$authority
[1] ""

$server
[1] "www.omegahat.org"

$user
[1] ""

$path
[1] "/RCurl/index.html"

$query
[1] ""

$fragment
[1] ""

$port
[1] 8080

attr(,"class")
[1] "URI"
>   parseURI("ftp://duncan@www.omegahat.org:8080/RCurl/index.html")
$scheme
[1] "ftp"

$authority
[1] ""

$server
[1] "www.omegahat.org"

$user
[1] "duncan"

$path
[1] "/RCurl/index.html"

$query
[1] ""

$fragment
[1] ""

$port
[1] 8080

attr(,"class")
[1] "URI"
> 
>   parseURI("ftp://duncan@www.omegahat.org:8080/RCurl/index.html#my_anchor")
$scheme
[1] "ftp"

$authority
[1] ""

$server
[1] "www.omegahat.org"

$user
[1] "duncan"

$path
[1] "/RCurl/index.html"

$query
[1] ""

$fragment
[1] "my_anchor"

$port
[1] 8080

attr(,"class")
[1] "URI"
> 
>   as(parseURI("http://duncan@www.omegahat.org:8080/RCurl/index.html#my_anchor"), "character")
[1] "http://duncan@www.omegahat.org:8080/RCurl/index.html#my_anchor"
> 
>   as(parseURI("ftp://duncan@www.omegahat.org:8080/RCurl/index.html?foo=1&bar=axd"), "character")
[1] "ftp://duncan@www.omegahat.org:8080/RCurl/index.html?foo=1&bar=axd"
> 
> 
> 
> cleanEx()
> nameEx("parseXMLAndAdd")
> ### * parseXMLAndAdd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parseXMLAndAdd
> ### Title: Parse XML content and add it to a node
> ### Aliases: parseXMLAndAdd
> ### Keywords: IO
> 
> ### ** Examples
> 
>   long = runif(10000, -122, -80)
>   lat = runif(10000, 25, 48)
> 
>   txt = sprintf("<Placemark><Point><coordinates>%.3f,%.3f,0</coordinates></Point></Placemark>",
+                   long, lat)
>   f = newXMLNode("Folder")
>   parseXMLAndAdd(txt, f)
>   xmlSize(f)
[1] 10000
> 
> 
> ## Not run: 
> ##D       # this version is much slower as i) we don't vectorize the
> ##D       #  creation of the XML nodes, and ii) the parsing of the XML
> ##D       # as a string is very fast as it is done in C.
> ##D   f = newXMLNode("Folder")
> ##D   mapply(function(a, b) {
> ##D            newXMLNode("Placemark", 
> ##D                        newXMLNode("Point", 
> ##D                                    newXMLNode("coordinates", 
> ##D                                                paste(a, b, "0", collapse = ","))), 
> ##D 		       parent = f)
> ##D            },
> ##D          long, lat) 
> ##D   xmlSize(f)
> ##D 
> ##D 
> ##D   o = c("<x>dog</x>", "<omg:x>cat</omg:x>")
> ##D   node = parseXMLAndAdd(o, nsDefs  = c("http://cran.r-project.org",
> ##D                                        omg = "http://www.omegahat.org"))
> ##D   xmlNamespace(node[[1]])
> ##D   xmlNamespace(node[[2]])
> ##D 
> ##D   tt = newXMLNode("myTop")
> ##D   node = parseXMLAndAdd(o, tt, nsDefs  = c("http://cran.r-project.org",
> ##D                                            omg = "http://www.omegahat.org"))
> ##D   tt
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("print")
> ### * print
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.XMLAttributeDef
> ### Title: Methods for displaying XML objects
> ### Aliases: print.XMLAttributeDef print.XMLCDataNode
> ###   print.XMLElementContent print.XMLElementDef print.XMLEntity
> ###   print.XMLEntityRef print.XMLNode print.XMLTextNode print.XMLComment
> ###   print.XMLOrContent print.XMLSequenceContent
> ###   print.XMLProcessingInstruction
> ### Keywords: IO file
> 
> ### ** Examples
> 
>   fileName <- system.file("exampleData", "event.xml", package ="XML")
> 
>      # Example of how to get faithful copy of the XML.
>   doc = xmlRoot(xmlTreeParse(fileName, trim = FALSE, ignoreBlanks = FALSE))
>   print(doc, indent = FALSE, tagSeparator = "")
<event date="2003-05-23" id="esc018">
  <dialog>
    <feature name="Date">2003-05-23</feature>
    <feature name="f2">1</feature>
    <feature name="f3">3</feature>
  </dialog>
  <dialog>
    <feature name="Date">2003-05-24</feature>
    <feature name="f2">17</feature>
    <feature name="f3">24</feature>
  </dialog>
  <dialog>
    <feature name="Date">http://mtadss01.mt.att.com/nlslogapp/displaysession.jsp?serviceid=esc018&amp;sessionid=2OLhD6ZX&amp;dat+e=2003_05_23</feature>
    <feature name="f2">17</feature>
    <feature name="f3">24</feature>
  </dialog>
</event>> 
>      # And now the default mechanism
>   doc = xmlRoot(xmlTreeParse(fileName))
>   print(doc)
<event date="2003-05-23" id="esc018">
 <dialog>
  <feature name="Date">2003-05-23</feature>
  <feature name="f2">1</feature>
  <feature name="f3">3</feature>
 </dialog>
 <dialog>
  <feature name="Date">2003-05-24</feature>
  <feature name="f2">17</feature>
  <feature name="f3">24</feature>
 </dialog>
 <dialog>
  <feature name="Date">http://mtadss01.mt.att.com/nlslogapp/displaysession.jsp?serviceid=esc018&amp;sessionid=2OLhD6ZX&amp;dat+e=2003_05_23</feature>
  <feature name="f2">17</feature>
  <feature name="f3">24</feature>
 </dialog>
</event>
> 
> 
> 
> cleanEx()
> nameEx("processXInclude")
> ### * processXInclude
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: processXInclude
> ### Title: Perform the XInclude substitutions
> ### Aliases: processXInclude processXInclude.list
> ###   processXInclude.XMLInternalDocument
> ###   processXInclude.XMLInternalElement
> ### Keywords: IO programming
> 
> ### ** Examples
> 
> 
>   f = system.file("exampleData", "include.xml", package = "XML")
>   doc = xmlInternalTreeParse(f, xinclude = FALSE)
> 
>   cat(saveXML(doc))
<?xml version="1.0"?>
<doc xmlns:xi="http://www.w3.org/2001/XInclude">
  <caveat>
    <para>This is a caveat that we repeat often.</para>
  </caveat>
  <section>
    <title>A</title>
    <xi:include xpointer="xpointer(//caveat[1])"/>
  </section>
  <section>
    <title>B</title>
    <xi:include xpointer="xpointer(/doc/caveat)"/>
  </section>
</doc>
>   sects = getNodeSet(doc, "//section")
>   sapply(sects, function(x) xmlName(x[[2]]))
[1] "include" "include"
>   processXInclude(doc)
[1] 2
> 
>   cat(saveXML(doc))
<?xml version="1.0"?>
<doc xmlns:xi="http://www.w3.org/2001/XInclude">
  <caveat>
    <para>This is a caveat that we repeat often.</para>
  </caveat>
  <section>
    <title>A</title>

    <caveat>
      <para>This is a caveat that we repeat often.</para>
    </caveat>

  </section>
  <section>
    <title>B</title>

    <caveat>
      <para>This is a caveat that we repeat often.</para>
    </caveat>

  </section>
</doc>
> 
>   f = system.file("exampleData", "include.xml", package = "XML")
>   doc = xmlInternalTreeParse(f, xinclude = FALSE)
>   section1 = getNodeSet(doc, "//section")[[1]]
> 
>      # process 
>   processXInclude(section1[[2]])
NULL
> 
> 
> 
> cleanEx()
> nameEx("readHTMLTable")
> ### * readHTMLTable
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readHTMLTable
> ### Title: Read data from one or more HTML tables
> ### Aliases: readHTMLTable readHTMLTable,character-method
> ###   readHTMLTable,HTMLInternalDocument-method
> ###   readHTMLTable,XMLInternalElementNode-method
> ###   coerce,character,FormattedInteger-method
> ###   coerce,character,FormattedNumber-method
> ###   coerce,character,Percent-method FormattedInteger-class
> ###   FormattedNumber-class Percent-class
> ### Keywords: IO data
> 
> ### ** Examples
> 
>  u = "http://en.wikipedia.org/wiki/World_population"
>  
>  tables = readHTMLTable(u)
>  names(tables)
 [1] "toc"                                                                                                                                                         
 [2] "NULL"                                                                                                                                                        
 [3] "NULL"                                                                                                                                                        
 [4] "World population milestones (USCB estimates)"                                                                                                                
 [5] "The 10 countries with the largest total population:"                                                                                                         
 [6] "The 10 most densely populated countries (with population above 1 million)"                                                                                   
 [7] "Countries ranking highly in terms of both total population (more than 15 million people) and population density (more than 250 people per square kilometer):"
 [8] "NULL"                                                                                                                                                        
 [9] "UN (medium variant, 2010 rev.) and US Census Bureau (December 2010) estimates[81][82]"                                                                       
[10] "UN 2008 estimates and medium variant projections (in millions)[84]"                                                                                          
[11] "World historical and predicted populations (in millions)[88][89][citation needed]"                                                                           
[12] "World historical and predicted populations by percentage distribution [88][89][citation needed]"                                                             
[13] "Estimated world population at various dates (in millions)[citation needed]"                                                                                  
[14] "Starting at 500 million"                                                                                                                                     
[15] "Starting at 375 million"                                                                                                                                     
[16] "NULL"                                                                                                                                                        
[17] "NULL"                                                                                                                                                        
[18] "NULL"                                                                                                                                                        
[19] "NULL"                                                                                                                                                        
> 
>  tables[[2]]
                                                                                                                                                                                                                                                                                                                                                            World population (millions)[12]
1                                                                                                                                                                                                                                                                                                                                                                                         #
2                                                                                                                                                                                                                                                                                                                                                                                         1
3                                                                                                                                                                                                                                                                                                                                                                                         2
4                                                                                                                                                                                                                                                                                                                                                                                         3
5                                                                                                                                                                                                                                                                                                                                                                                         4
6                                                                                                                                                                                                                                                                                                                                                                                         5
7                                                                                                                                                                                                                                                                                                                                                                                         6
8                                                                                                                                                                                                                                                                                                                                                                                         7
9                                                                                                                                                                                                                                                                                                                                                                                         8
10                                                                                                                                                                                                                                                                                                                                                                                        9
11                                                                                                                                                                                                                                                                                                                                                                                       10
12                                                                                                                                                                                                                                                                                                                                                                                         
13                                                                                                                                                                                                                                                                                                                                                                                         
14                                                                                                                                                                                                                                                                                                                                                                                        1
15                                                                                                                                                                                                                                                                                                                                                                                         
16                                                                                                                                                                                                                                                                                                                                                                                         
17                                                                                                                                                                                                                                                                                                                                                                                        2
18                                                                                                                                                                                                                                                                                                                                                                                        3
19                                                                                                                                                                                                                                                                                                                                                                                         
20                                                                                                                                                                                                                                                                                                                                                                                         
21                                                                                                                                                                                                                                                                                                                                                                                        4
22                                                                                                                                                                                                                                                                                                                                                                                        5
23                                                                                                                                                                                                                                                                                                                                                                                        6
24                                                                                                                                                                                                                                                                                                                                                                                         
25                                                                                                                                                                                                                                                                                                                                                                                         
26                                                                                                                                                                                                                                                                                                                                                                                         
27                                                                                                                                                                                                                                                                                                                                                                                         
28                                                                                                                                                                                                                                                                                                                                                                                         
29 Geographical definitions as in IEA Key Stats 2010 p.66\nNotes:\nEurope = OECD Europe + Non-OECD Europe and\nexcluding Russia and including Estonia, Latvia and Lithuania\nex Soviet Union (SU) = SU excluding Russia and Baltic states\nNorth America = US, Canada, Mexico\nOECD Pacific = Australia, Japan, Korea, New Zealand\n2025 = with constant annual 2007/2008 growth until 2025
                           NA     NA     NA     NA
1       Top ten most populous   1990   2008  2025*
2                       China  1,141  1,333  1,458
3                       India    849  1,140  1,398
4                          US    250    304    352
5                   Indonesia    178    228    273
6                      Brazil    150    192    223
7                    Pakistan    108    166    226
8                  Bangladesh    116    160    198
9                     Nigeria     94    151    208
10                     Russia    148    142    137
11                      Japan    124    128    126
12                World total  5,265  6,688  8,004
13  Top ten most populous (%) 60.0% 58.9% 57.5%
14                       Asia  1,613  2,183  2,693
15                    + China  1,141  1,333  1,458
16            + OECD Pacific*    187    202    210
17                     Africa    634    984  1,365
18                    Europe*    564    603    659
19                   + Russia    148    142    137
20         + ex Soviet Union*    133    136    146
21              Latin America    355    462    550
22             North America*    359    444    514
23                Middle East    132    199    272
24                       <NA>   <NA>   <NA>   <NA>
25                  Australia     17     22     28
26 European Union  27 states    473    499    539
27                US + Canada    278    338    392
28            Ex Soviet Union    289    285    289
29                       <NA>   <NA>   <NA>   <NA>
>   # Print the table. Note that the values are all characters
>   # not numbers. Also the column names have a preceding X since
>   # R doesn't allow the variable names to start with digits.
>  tmp = tables[[2]]
> 
>   # We can transform this to get the rows to be years and the columns
>   # to be population counts. We'll create a matrix.
>  vals = cbind(year = as.integer(gsub("X", "", names(tmp)[-1])),
+               matrix(as.integer(gsub(",", "", as.character(unlist(tmp[-1])))),
+                       ncol(tmp)-1, byrow = TRUE, dimnames = list(NULL, as.character(tmp[[1]]))))
Warning in matrix(as.integer(gsub(",", "", as.character(unlist(tmp[-1])))),  :
  NAs introduced by coercion
> 
>    # Let's just read the second table directly by itself.
>  doc = htmlParse(u)
>  tableNodes = getNodeSet(doc, "//table")
>  tb = readHTMLTable(tableNodes[[2]])
> 
>   # Let's try to adapt the values on the fly.
>   # We'll create a function that turns a th/td node into a val
>  tryAsInteger = function(node) {
+                   val = xmlValue(node)
+                   ans = as.integer(gsub(",", "", val))
+                   if(is.na(ans))
+                       val
+                   else
+                       ans
+                 }
> 
>  tb = readHTMLTable(tableNodes[[2]], elFun = tryAsInteger)
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
> 
>  tb = readHTMLTable(tableNodes[[2]], elFun = tryAsInteger,
+                        colClasses = c("character", rep("integer", 9)))
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in function (node)  : NAs introduced by coercion
Warning in asMethod(object) : NAs introduced by coercion
Warning in asMethod(object) : NAs introduced by coercion
Warning in asMethod(object) : NAs introduced by coercion
Warning in asMethod(object) : NAs introduced by coercion
> 
> 
>   zz = readHTMLTable("http://www.inflationdata.com/Inflation/Consumer_Price_Index/HistoricalCPI.aspx")
>   if(any(i <- sapply(zz, ncol) == 14)) {  # guard against the structure of the page changing.
+     zz = zz[[which(i)[1]]]  # 4th table
+         # convert columns to numeric.  Could use colClasses in the call to readHTMLTable()
+     zz[-1] = lapply(zz[-1], function(x) as.numeric(gsub(".* ", "", as.character(x))))
+     matplot(1:12, t(zz[-c(1, 14)]), type = "l")
+   }
> 
> 
> # From Marsh Feldman on R-help
> doc <- "http://www.nber.org/cycles/cyclesmain.html"
>      # The  main table is the second one because it's embedded in the page table.
> table <- getNodeSet(htmlParse(doc),"//table") [[2]]   
> xt <- readHTMLTable(table,
+                     header = c("peak","trough","contraction",
+                                "expansion","trough2trough","peak2peak"),
+                     colClasses = c("character","character","character",
+                                    "character","character","character"),
+                     trim = TRUE, stringsAsFactors = FALSE
+                    )
> 
> 
> if(FALSE) {
+  # Here is a totally different way of reading tables from HTML documents.
+  # The data are formatted using a PRE and so can be read via read.table
+  u = "http://tidesonline.nos.noaa.gov/data_read.shtml?station_info=9414290+San+Francisco,+CA"
+  h = htmlParse(u)
+  p = getNodeSet(h, "//pre")
+  con = textConnection(xmlValue(p[[2]]))
+  tides = read.table(con)
+ }
> 
>    # header as a logical vector
>  tt = readHTMLTable("http://www.sfgate.com/weather/rainfall.shtml",
+                      header = c(FALSE, FALSE, TRUE, FALSE, FALSE))
> 
>    #
>  tt = readHTMLTable("http://www.sfgate.com/weather/rainfall.shtml",
+                         which = 3, header = TRUE)
> 
> 
> if(require(RCurl)) {
+   tt =  getURL("http://www.omegahat.org/RCurl/testPassword/table.html",  userpwd = "bob:duncantl")
+   readHTMLTable(tt)
+ }
Loading required package: RCurl
Loading required package: bitops
$`NULL`
  Age Count
1   5    20
2   6    32
3   7    34
4   8    10

> 
> 
> 
> cleanEx()

detaching package:RCurl, package:bitops

> nameEx("saveXML")
> ### * saveXML
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: saveXML
> ### Title: Output internal XML Tree
> ### Aliases: saveXML saveXML.XMLInternalDocument saveXML.XMLInternalDOM
> ###   saveXML.XMLInternalNode saveXML.XMLNode saveXML.XMLOutputStream
> ###   coerce,XMLInternalDocument,character-method
> ###   coerce,XMLInternalDOM,character-method
> ###   coerce,XMLInternalNode,character-method saveXML,XMLFlatTree-method
> ###   saveXML,XMLInternalDocument-method saveXML,XMLInternalDOM-method
> ###   saveXML,XMLInternalNode-method saveXML,XMLNode-method
> ###   saveXML,XMLOutputStream-method saveXML,HTMLInternalDocument-method
> ### Keywords: IO file
> 
> ### ** Examples
> 
> 
>  b = newXMLNode("bob")
>  saveXML(b)
[1] "<bob/>"
> 
>  f = tempfile()
>  saveXML(b, f)
[1] "/var/folders/f8/2dd5rdyx1bjbw4jttt0x1hm80000gn/T//RtmptuGCKQ/file8c4630036ee"
>  doc = xmlInternalTreeParse(f)
>  saveXML(doc)
[1] "<?xml version=\"1.0\"?>\n<bob/>\n"
> 
> 
> con <- xmlOutputDOM()
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> con$addTag("author", "Duncan Temple Lang")
> con$addTag("address",  close=FALSE)
> con$addTag("office", "2C-259")
> con$addTag("street", "Mountain Avenue.")
> con$addTag("phone", close=FALSE)
> con$addTag("area", "908", attrs=c(state="NJ"))
> con$addTag("number", "582-3217")
> con$closeTag() # phone
> con$closeTag() # address
> 
> saveXML(con$value(), file="out.xml")
[1] "out.xml"
> 
> 
> # Work with entities
> 
>  f = system.file("exampleData", "test1.xml", package = "XML")
>  doc = xmlRoot(xmlTreeParse(f))
>  outFile = tempfile()
>  saveXML(doc, outFile)
[1] "/var/folders/f8/2dd5rdyx1bjbw4jttt0x1hm80000gn/T//RtmptuGCKQ/file8c4631644cc"
>  alt = xmlRoot(xmlTreeParse(outFile))
>  if(! identical(doc, alt) )
+   stop("Problems handling entities!")
> 
>  con = textConnection("test1.xml", "w")
>  saveXML(doc, con)
     description            class             mode             text 
     "test1.xml" "textConnection"              "w"           "text" 
          opened         can read        can write 
        "opened"             "no"            "yes" 
>  close(con)
>  alt = get("test1.xml")
>  identical(doc, alt)
[1] FALSE
> 
> 
> 
>  x = newXMLNode("a", "some text", newXMLNode("c", "sub text"), "more text")
Warning in removeNodes.list(kids) :
  removeNode only works on internal nodes at present
> 
>  cat(saveXML(x), "\n")
<a>some text<c>sub text</c>more text</a> 
> 
>  cat(as(x, "character"), "\n")
<a>some text<c>sub text</c>more text</a> 
> 
> 
>      # Showing the prefix parameter
>   doc = newXMLDoc()
>   n = newXMLNode("top", doc = doc)
>   b = newXMLNode("bar", parent = n)
> 
>      # suppress the <?xml ...?>
>   saveXML(doc, prefix = character())
[1] "<top>\n  <bar/>\n</top>"
> 
>      # put our own comment in
>   saveXML(doc, prefix = "<!-- This is an alternative prefix -->")
[1] "<!-- This is an alternative prefix -->\n<top>\n  <bar/>\n</top>"
>      # or use a comment node.
>   saveXML(doc, prefix = newXMLCommentNode("This is an alternative prefix"))
[1] "<!--This is an alternative prefix-->\n<top>\n  <bar/>\n</top>"
> 
> 
> 
> cleanEx()
> nameEx("supportsExpat")
> ### * supportsExpat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: supportsExpat
> ### Title: Determines which native XML parsers are being used.
> ### Aliases: supportsExpat supportsLibxml
> ### Keywords: file
> 
> ### ** Examples
> 
>      # use Expat if possible, otherwise libxml
>   fileName <- system.file("exampleData", "mtcars.xml", package="XML")
>   xmlEventParse(fileName, useExpat = supportsExpat())
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
$startElement
function (name, atts, ...) 
{
    con$addTag(name, attrs = atts, close = FALSE)
}
<environment: 0x7fa8ed06c340>

$endElement
function (name) 
{
    con$closeTag(name)
}
<environment: 0x7fa8ed06c340>

$processingInstruction
function (sys, value) 
{
    con$addNode(xmlPINode(sys, value))
}
<environment: 0x7fa8ed06c340>

$text
function (x, ...) 
{
    con$addNode(xmlTextNode(x))
}
<environment: 0x7fa8ed06c340>

$comment
function (x, ...) 
{
    xmlCommentNode(x)
}
<environment: 0x7fa8ed06c340>

$externalEntity
function (ctxt, baseURI, sysId, publicId, ...) 
{
    cat("externalEntity", ctxt, baseURI, sysId, publicId, "\n")
}
<environment: 0x7fa8ed06c340>

$entityDeclaration
function (name, baseURI, sysId, publicId, notation, ...) 
{
    cat("externalEntity", name, baseURI, sysId, publicId, notation, 
        "\n")
}
<environment: 0x7fa8ed06c340>

$dom
function () 
{
    con
}
<environment: 0x7fa8ed06c340>

> 
> 
> 
> cleanEx()
> nameEx("toHTML")
> ### * toHTML
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: toHTML
> ### Title: Create an HTML representation of the given R object, using
> ###   internal C-level nodes
> ### Aliases: toHTML toHTML,vector-method toHTML,matrix-method
> ###   toHTML,call-method
> ### Keywords: IO programming
> 
> ### ** Examples
> 
>  cat(as(toHTML(rnorm(10)), "character"))
<table>
  <tr>
    <th>-0.6264538</th>
    <th>0.1836433</th>
    <th>-0.8356286</th>
    <th>1.595281</th>
    <th>0.3295078</th>
    <th>-0.8204684</th>
    <th>0.4874291</th>
    <th>0.7383247</th>
    <th>0.5757814</th>
    <th>-0.3053884</th>
  </tr>
</table>> 
> 
> 
> cleanEx()
> nameEx("toString")
> ### * toString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: toString.XMLNode
> ### Title: Creates string representation of XML node
> ### Aliases: toString.XMLNode
> ### Keywords: file
> 
> ### ** Examples
> 
>  x <- xmlRoot(xmlTreeParse(system.file("exampleData", "gnumeric.xml", package = "XML")))
> 
>  toString(x)
[1] "<gmr:Workbook xmlns:gmr=\"http://www.gnome.org/gnumeric/v2\">\n <gmr:Summary>\n  <gmr:Item>\n   <gmr:name>Application</gmr:name>\n   <gmr:val-string>gnumeric</gmr:val-string>\n  </gmr:Item>\n  <gmr:Item>\n   <gmr:name>Author</gmr:name>\n   <gmr:val-string>Duncan Temple Lang</gmr:val-string>\n  </gmr:Item>\n </gmr:Summary>\n <gmr:Geometry Width=\"600\" Height=\"400\"/>\n <gmr:Sheets>\n  <gmr:Sheet>\n   <gmr:Name>Sheet1</gmr:Name>\n   <gmr:MaxCol>1</gmr:MaxCol>\n   <gmr:MaxRow>7</gmr:MaxRow>\n   <gmr:Zoom>1.000000</gmr:Zoom>\n   <gmr:CellStyles>\n    <gmr:Style No=\"1\" HAlign=\"1\" VAlign=\"4\" Fit=\"0\" Orient=\"1\" Shade=\"0\" Format=\"mm/dd/yyyy\">\n     <gmr:Font Unit=\"12.000000\" Bold=\"0\" Italic=\"0\">Helvetica</gmr:Font>\n    </gmr:Style>\n    <gmr:Style No=\"2\" HAlign=\"1\" VAlign=\"4\" Fit=\"0\" Orient=\"1\" Shade=\"0\" Format=\"General\">\n     <gmr:Font Unit=\"12.000000\" Bold=\"0\" Italic=\"0\">Helvetica</gmr:Font>\n    </gmr:Style>\n    <gmr:Style No=\"3\" HAlign=\"8\" VAlign=\"4\" Fit=\"0\" Orient=\"1\" Shade=\"0\" Format=\"General\">\n     <gmr:Font Unit=\"12.000000\" Bold=\"0\" Italic=\"0\">Helvetica</gmr:Font>\n    </gmr:Style>\n   </gmr:CellStyles>\n   <gmr:Cols>\n    <gmr:ColInfo No=\"0\" Unit=\"80.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:ColInfo No=\"1\" Unit=\"80.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n   </gmr:Cols>\n   <gmr:Rows>\n    <gmr:RowInfo No=\"1\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"2\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"3\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"4\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"5\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"6\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n    <gmr:RowInfo No=\"7\" Unit=\"18.000000\" MarginA=\"1.000000\" MarginB=\"1.000000\" HardSize=\"0\"/>\n   </gmr:Rows>\n   <gmr:Cells>\n    <gmr:Cell Col=\"1\" Row=\"7\" Style=\"1\">\n     <gmr:Content>36524</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"0\" Row=\"4\" Style=\"2\">\n     <gmr:Content>4</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"4\" Style=\"3\">\n     <gmr:Content>d</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"0\" Row=\"1\" Style=\"2\">\n     <gmr:Content>1</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"1\" Style=\"3\">\n     <gmr:Content>x</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"5\" Style=\"3\">\n     <gmr:Content>sd</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"0\" Row=\"2\" Style=\"2\">\n     <gmr:Content>2</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"0\" Row=\"6\" Style=\"2\">\n     <gmr:Content>5</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"2\" Style=\"3\">\n     <gmr:Content>s</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"6\" Style=\"3\">\n     <gmr:Content>dsa</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"0\" Row=\"3\" Style=\"2\">\n     <gmr:Content>3</gmr:Content>\n    </gmr:Cell>\n    <gmr:Cell Col=\"1\" Row=\"3\" Style=\"3\">\n     <gmr:Content>as</gmr:Content>\n    </gmr:Cell>\n   </gmr:Cells>\n  </gmr:Sheet>\n </gmr:Sheets>\n</gmr:Workbook>"
> 
> 
> 
> cleanEx()
> nameEx("xmlApply")
> ### * xmlApply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlApply
> ### Title: Applies a function to each of the children of an XMLNode
> ### Aliases: xmlApply xmlApply.XMLNode xmlApply.XMLDocument
> ###   xmlApply.XMLDocumentContent xmlSApply xmlSApply.XMLNode
> ###   xmlSApply.XMLDocument xmlSApply.XMLDocumentContent
> ### Keywords: file
> 
> ### ** Examples
> 
>  doc <- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
>  r <- xmlRoot(doc)
>  xmlSApply(r[[2]], xmlName)
  text 
"text" 
> 
>  xmlApply(r[[2]], xmlAttrs)
$text
NULL

> 
>  xmlSApply(r[[2]], xmlSize)
text 
   0 
> 
> 
> 
> 
> cleanEx()
> nameEx("xmlAttrs")
> ### * xmlAttrs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlAttrs
> ### Title: Get the list of attributes of an XML node.
> ### Aliases: xmlAttrs xmlAttrs<- xmlAttrs.XMLElementDef xmlAttrs<-,XMLNode
> ###   xmlAttrs<-,XMLInternalNode xmlAttrs<-,XMLNode-method
> ###   xmlAttrs<-,XMLInternalElementNode-method xmlAttrs.XMLNode
> ###   xmlAttrs.XMLInternalNode
> ### Keywords: IO file
> 
> ### ** Examples
> 
>  fileName <- system.file("exampleData", "mtcars.xml", package="XML") 
>  doc <- xmlTreeParse(fileName)
> 
>  xmlAttrs(xmlRoot(doc))
       name  numRecords      source 
   "mtcars"        "32" "R Project" 
> 
>  xmlAttrs(xmlRoot(doc)[["variables"]])
count 
 "11" 
> 
> 
>  doc <- xmlParse(fileName)
>  d = xmlRoot(doc)
> 
>  xmlAttrs(d)
       name  numRecords      source 
   "mtcars"        "32" "R Project" 
>  xmlAttrs(d) <- c(name = "Motor Trend fuel consumption data",
+                   author = "Motor Trends")
>  xmlAttrs(d)
                               name                          numRecords 
"Motor Trend fuel consumption data"                                "32" 
                             source                              author 
                        "R Project"                      "Motor Trends" 
> 
>    # clear all the attributes and then set new ones.
>  removeAttributes(d)
<dataset>
  <variables count="11">
    <variable unit="Miles/gallon">mpg</variable>
    <variable>cyl</variable>
    <variable>disp</variable>
    <variable>hp</variable>
    <variable>drat</variable>
    <variable>wt</variable>
    <variable>qsec</variable>
    <variable>vs</variable>
    <variable type="FactorVariable" levels="automatic,manual">am</variable>
    <variable>gear</variable>
    <variable>carb</variable>
  </variables>
  <record id="Mazda RX4">   21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</record>
  <record id="Mazda RX4 Wag"> 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4</record>
  <record id="Datsun 710">  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</record>
  <record id="Hornet 4 Drive">      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1</record>
  <record id="Hornet Sportabout">   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</record>
  <record id="Valiant">             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1</record>
  <record id="Duster 360">          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</record>
  <record id="Merc 240D">           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</record>
  <record id="Merc 230">            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2</record>
  <record id="Merc 280">            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</record>
  <record id="Merc 280C">           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4</record>
  <record id="Merc 450SE">          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</record>
  <record id="Merc 450SL">          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</record>
  <record id="Merc 450SLC">         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</record>
  <record id="Cadillac Fleetwood">  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</record>
  <record id="Lincoln Continental"> 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</record>
  <record id="Chrysler Imperial">   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</record>
  <record id="Fiat 128">            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</record>
  <record id="Honda Civic">         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</record>
  <record id="Toyota Corolla">      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</record>
  <record id="Toyota Corona">       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1</record>
  <record id="Dodge Challenger">    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2</record>
  <record id="AMC Javelin">         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2</record>
  <record id="Camaro Z28">          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</record>
  <record id="Pontiac Firebird">    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</record>
  <record id="Fiat X1-9">           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</record>
  <record id="Porsche 914-2">       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</record>
  <record id="Lotus Europa">        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</record>
  <record id="Ford Pantera L">      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</record>
  <record id="Ferrari Dino">        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</record>
  <record id="Maserati Bora">       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</record>
  <record id="Volvo 142E">          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</record>
</dataset> 
>  xmlAttrs(d) <- c(name = "Motor Trend fuel consumption data",
+                   author = "Motor Trends")
> 
> 
>      # Show how to get the attributes with and without the prefix and
>      # with and without the URLs for the namespaces.
>   doc = xmlParse('<doc xmlns:r="http://www.r-project.org">
+                     <el r:width="10" width="72"/>
+                     <el width="46"/>
+                     </doc>')
> 
>   xmlAttrs(xmlRoot(doc)[[1]], TRUE, TRUE)
r:width   width 
   "10"    "72" 
attr(,"namespaces")
http://www.r-project.org                          
                     "r"                       "" 
>   xmlAttrs(xmlRoot(doc)[[1]], FALSE, TRUE)
width width 
 "10"  "72" 
attr(,"namespaces")
http://www.r-project.org                          
                     "r"                       "" 
>   xmlAttrs(xmlRoot(doc)[[1]], TRUE, FALSE)
r:width   width 
   "10"    "72" 
attr(,"namespaces")
[1] "r" "" 
>   xmlAttrs(xmlRoot(doc)[[1]], FALSE, FALSE)
width width 
 "10"  "72" 
> 
> 
> 
> cleanEx()
> nameEx("xmlChildren")
> ### * xmlChildren
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlChildren
> ### Title: Gets the sub-nodes within an XMLNode object.
> ### Aliases: xmlChildren xmlChildren<- xmlChildren.XMLNode
> ###   xmlChildren.XMLInternalNode xmlChildren.XMLInternalDocument
> ###   xmlChildren<-,XMLInternalNode-method xmlChildren<-,ANY-method
> ### Keywords: file
> 
> ### ** Examples
> 
>   fileName <- system.file("exampleData", "mtcars.xml", package="XML")
>   doc <- xmlTreeParse(fileName)
>   names(xmlChildren(doc$doc$children[["dataset"]]))
 [1] "variables" "record"    "record"    "record"    "record"    "record"   
 [7] "record"    "record"    "record"    "record"    "record"    "record"   
[13] "record"    "record"    "record"    "record"    "record"    "record"   
[19] "record"    "record"    "record"    "record"    "record"    "record"   
[25] "record"    "record"    "record"    "record"    "record"    "record"   
[31] "record"    "record"    "record"   
> 
> 
> 
> cleanEx()
> nameEx("xmlContainsEntity")
> ### * xmlContainsEntity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlContainsEntity
> ### Title: Checks if an entity is defined within a DTD.
> ### Aliases: xmlContainsEntity xmlContainsElement
> ### Keywords: file
> 
> ### ** Examples
> 
>  dtdFile <- system.file("exampleData", "foo.dtd", package="XML")
>  foo.dtd <- parseDTD(dtdFile)
>  
>   # Look for entities.
>  xmlContainsEntity("foo", foo.dtd)
[1] FALSE
>  xmlContainsEntity("bar", foo.dtd)
[1] FALSE
> 
>   # Now look for an element
>  xmlContainsElement("record", foo.dtd)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("xmlDOMApply")
> ### * xmlDOMApply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlDOMApply
> ### Title: Apply function to nodes in an XML tree/DOM.
> ### Aliases: xmlDOMApply
> ### Keywords: file
> 
> ### ** Examples
> 
>  dom <- xmlTreeParse(system.file("exampleData","mtcars.xml", package="XML"))
>  tagNames <- function() {
+     tags <- character(0)
+     add <- function(x) {
+       if(inherits(x, "XMLNode")) {
+         if(is.na(match(xmlName(x), tags)))
+            tags <<- c(tags, xmlName(x))
+       }
+ 
+       NULL
+     }
+ 
+     return(list(add=add, tagNames = function() {return(tags)}))
+  }
> 
>  h <- tagNames()
>  xmlDOMApply(xmlRoot(dom), h$add) 
NULL
>  h$tagNames()
[1] "text"      "variable"  "variables" "record"    "dataset"  
> 
> 
> 
> cleanEx()
> nameEx("xmlElementSummary")
> ### * xmlElementSummary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlElementSummary
> ### Title: Frequency table of names of elements and attributes in XML
> ###   content
> ### Aliases: xmlElementSummary
> ### Keywords: IO
> 
> ### ** Examples
> 
>   xmlElementSummary(system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML"))
$nodeCounts
           Cube gesmes:Envelope  gesmes:subject   gesmes:Sender     gesmes:name 
          60086               1               1               1               1 

$attributes
$attributes$`gesmes:Envelope`
xmlns:gesmes        xmlns 
           1            1 

$attributes$Cube
    time currency     rate 
    1991    58094    58094 


> 
> 
> 
> cleanEx()
> nameEx("xmlElementsByTagName")
> ### * xmlElementsByTagName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlElementsByTagName
> ### Title: Retrieve the children of an XML node with a specific tag name
> ### Aliases: xmlElementsByTagName
> ### Keywords: IO file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  doc <- xmlTreeParse("http://www.omegahat.org/Scripts/Data/mtcars.xml")
> ##D  xmlElementsByTagName(doc$children[[1]], "variable")
> ## End(Not run)
> 
>  doc <- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
>  xmlElementsByTagName(xmlRoot(doc)[[1]], "variable")
$variable
<variable unit="Miles/gallon">mpg</variable>

$variable
<variable>cyl</variable>

$variable
<variable>disp</variable>

$variable
<variable>hp</variable>

$variable
<variable>drat</variable>

$variable
<variable>wt</variable>

$variable
<variable>qsec</variable>

$variable
<variable>vs</variable>

$variable
<variable type="FactorVariable" levels="automatic,manual">am</variable>

$variable
<variable>gear</variable>

$variable
<variable>carb</variable>

> 
> 
> 
> cleanEx()
> nameEx("xmlEventHandler")
> ### * xmlEventHandler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlEventHandler
> ### Title: Default handlers for the SAX-style event XML parser
> ### Aliases: xmlEventHandler
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  xmlEventParse(system.file("exampleData", "mtcars.xml", package="XML"),
+                handlers=xmlEventHandler())
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
$startElement
function (name, atts, ...) 
{
    con$addTag(name, attrs = atts, close = FALSE)
}
<environment: 0x7fa8f3043228>

$endElement
function (name) 
{
    con$closeTag(name)
}
<environment: 0x7fa8f3043228>

$processingInstruction
function (sys, value) 
{
    con$addNode(xmlPINode(sys, value))
}
<environment: 0x7fa8f3043228>

$text
function (x, ...) 
{
    con$addNode(xmlTextNode(x))
}
<environment: 0x7fa8f3043228>

$comment
function (x, ...) 
{
    xmlCommentNode(x)
}
<environment: 0x7fa8f3043228>

$externalEntity
function (ctxt, baseURI, sysId, publicId, ...) 
{
    cat("externalEntity", ctxt, baseURI, sysId, publicId, "\n")
}
<environment: 0x7fa8f3043228>

$entityDeclaration
function (name, baseURI, sysId, publicId, notation, ...) 
{
    cat("externalEntity", name, baseURI, sysId, publicId, notation, 
        "\n")
}
<environment: 0x7fa8f3043228>

$dom
function () 
{
    con
}
<environment: 0x7fa8f3043228>

> 
> 
> 
> cleanEx()
> nameEx("xmlEventParse")
> ### * xmlEventParse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlEventParse
> ### Title: XML Event/Callback element-wise Parser
> ### Aliases: xmlEventParse
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  fileName <- system.file("exampleData", "mtcars.xml", package="XML")
> 
>    # Print the name of each XML tag encountered at the beginning of each
>    # tag.
>    # Uses the libxml SAX parser.
>  xmlEventParse(fileName,
+                 list(startElement=function(name, attrs){
+                                     cat(name,"\n")
+                                   }),
+                 useTagName=FALSE, addContext = FALSE)
dataset 
variables 
variable 
variable 
variable 
variable 
variable 
variable 
variable 
variable 
variable 
variable 
variable 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
record 
$startElement
function (name, attrs) 
{
    cat(name, "\n")
}

> 
> 
> ## Not run: 
> ##D   # Parse the text rather than a file or URL by reading the URL's contents
> ##D   # and making it a single string. Then call xmlEventParse
> ##D xmlURL <- "http://www.omegahat.org/Scripts/Data/mtcars.xml"
> ##D xmlText <- paste(scan(xmlURL, what="",sep="\n"),"\n",collapse="\n")
> ##D xmlEventParse(xmlText, asText=TRUE)
> ## End(Not run)
> 
>     # Using a state object to share mutable data across callbacks
> f <- system.file("exampleData", "gnumeric.xml", package = "XML")
> zz <- xmlEventParse(f,
+                     handlers = list(startElement=function(name, atts, .state) {
+                                                      .state = .state + 1
+                                                      print(.state)
+                                                      .state
+                                                  }), state = 0)
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
[1] 11
[1] 12
[1] 13
[1] 14
[1] 15
[1] 16
[1] 17
[1] 18
[1] 19
[1] 20
[1] 21
[1] 22
[1] 23
[1] 24
[1] 25
[1] 26
[1] 27
[1] 28
[1] 29
[1] 30
[1] 31
[1] 32
[1] 33
[1] 34
[1] 35
[1] 36
[1] 37
[1] 38
[1] 39
[1] 40
[1] 41
[1] 42
[1] 43
[1] 44
[1] 45
[1] 46
[1] 47
[1] 48
[1] 49
[1] 50
[1] 51
[1] 52
[1] 53
[1] 54
[1] 55
[1] 56
[1] 57
[1] 58
> print(zz)
[1] 58
> 
> 
> 
> 
>     # Illustrate the startDocument and endDocument handlers.
> xmlEventParse(fileName,
+                handlers = list(startDocument = function() {
+                                                  cat("Starting document\n")
+                                                },
+                                endDocument = function() {
+                                                  cat("ending document\n")
+                                              }),
+                saxVersion = 2)
Starting document
ending document
$startDocument
function () 
{
    cat("Starting document\n")
}

$endDocument
function () 
{
    cat("ending document\n")
}

> 
> 
> 
> 
> if(libxmlVersion()$major >= 2) {
+ 
+ 
+  startElement = function(x, ...) cat(x, "\n")
+ 
+ 
+  xmlEventParse(file(f), handlers = list(startElement = startElement))
+ 
+ 
+  # Parse with a function providing the input as needed.
+  xmlConnection = 
+   function(con) {
+ 
+    if(is.character(con))
+      con = file(con, "r")
+   
+    if(isOpen(con, "r"))
+      open(con, "r")
+ 
+    function(len) {
+ 
+      if(len < 0) {
+         close(con)
+         return(character(0))
+      }
+ 
+       x = character(0)
+       tmp = ""
+     while(length(tmp) > 0 && nchar(tmp) == 0) {
+       tmp = readLines(con, 1)
+       if(length(tmp) == 0)
+         break
+       if(nchar(tmp) == 0)
+         x = append(x, "\n")
+       else
+         x = tmp
+     }
+     if(length(tmp) == 0)
+       return(tmp)
+   
+     x = paste(x, collapse="")
+ 
+     x
+   }
+  }
+ 
+  ff = xmlConnection(f)
+  xmlEventParse(ff, handlers = list(startElement = startElement))
+ 
+   # Parse from a connection. Each time the parser needs more input, it
+   # calls readLines(<con>, 1)
+  xmlEventParse(file(f),  handlers = list(startElement = startElement))
+ 
+ 
+   # using SAX 2
+  h = list(startElement = function(name, attrs, namespace, allNamespaces){ 
+                                  cat("Starting", name,"\n")
+                                  if(length(attrs))
+                                      print(attrs)
+                                  print(namespace)
+                                  print(allNamespaces)
+                          },
+           endElement = function(name, uri) {
+                           cat("Finishing", name, "\n")
+             }) 
+  xmlEventParse(system.file("exampleData", "namespaces.xml", package="XML"), handlers = h, saxVersion = 2)
+ 
+ 
+  # This example is not very realistic but illustrates how to use the
+  # branches argument. It forces the creation of complete nodes for
+  # elements named <b> and extracts the id attribute.
+  # This could be done directly on the startElement, but this just
+  # illustrates the mechanism.
+  filename = system.file("exampleData", "branch.xml", package="XML")
+  b.counter = function() {
+                 nodes <- character()
+                 f = function(node) { nodes <<- c(nodes, xmlGetAttr(node, "id"))}
+                 list(b = f, nodes = function() nodes)
+              }
+ 
+   b = b.counter()
+   invisible(xmlEventParse(filename, branches = b["b"]))
+   b$nodes()
+ 
+ 
+   filename = system.file("exampleData", "branch.xml", package="XML")
+    
+   invisible(xmlEventParse(filename, branches = list(b = function(node) {print(names(node))})))
+   invisible(xmlEventParse(filename, branches = list(b = function(node) {print(xmlName(xmlChildren(node)[[1]]))})))
+ }
gmr:Workbook 
gmr:Summary 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Geometry 
gmr:Sheets 
gmr:Sheet 
gmr:Name 
gmr:MaxCol 
gmr:MaxRow 
gmr:Zoom 
gmr:CellStyles 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Cols 
gmr:ColInfo 
gmr:ColInfo 
gmr:Rows 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:Cells 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
Warning in open.connection(con, "r") : connection is already open
gmr:Workbook 
gmr:Summary 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Geometry 
gmr:Sheets 
gmr:Sheet 
gmr:Name 
gmr:MaxCol 
gmr:MaxRow 
gmr:Zoom 
gmr:CellStyles 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Cols 
gmr:ColInfo 
gmr:ColInfo 
gmr:Rows 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:Cells 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Workbook 
gmr:Summary 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Item 
gmr:name 
gmr:val-string 
gmr:Geometry 
gmr:Sheets 
gmr:Sheet 
gmr:Name 
gmr:MaxCol 
gmr:MaxRow 
gmr:Zoom 
gmr:CellStyles 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Style 
gmr:Font 
gmr:Cols 
gmr:ColInfo 
gmr:ColInfo 
gmr:Rows 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:RowInfo 
gmr:Cells 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
gmr:Cell 
gmr:Content 
Starting a 
                          
"http://www.omegahat.org" 
                                             omegahat 
 "http://www.omegahat.org"  "http://www.omegahat.org" 
                         r 
"http://www.r-project.org" 
Starting b 
      foo 
"myValue" 
attr(,"namespaces")
                 omegahat 
"http://www.omegahat.org" 
                         r 
"http://www.r-project.org" 
named character(0)
Starting defaultNs 
                          
"http://www.omegahat.org" 
named character(0)
Finishing defaultNs 
Starting c 
                 c 
"http://www.c.org" 
                 c 
"http://www.c.org" 
Finishing c 
Finishing b 
Finishing a 
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
Warning: closing unused connection 5 (/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/gnumeric.xml)
Warning: closing unused connection 3 (/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/gnumeric.xml)
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
  text      f      g 
"text"    "f"    "g" 
      f   g 
 NA "f" "g" 
  f   g 
"f" "g" 
  f   g   b 
"f" "g" "b" 
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
[1] "text"
[1] NA
[1] "f"
[1] "f"
> 
>   
>   ############################################
>   # Stopping the parser mid-way and an example of using XMLParserContextFunction.
> 
>   startElement =
+   function(ctxt, name, attrs, ...)  {
+     print(ctxt)
+       print(name)
+       if(name == "rewriteURI") {
+            cat("Terminating parser\n")
+ 	   xmlStopParser(ctxt)
+       }
+   }
>   class(startElement) = "XMLParserContextFunction"  
>   endElement =
+   function(name, ...) 
+     cat("ending", name, "\n")
> 
>   fileName = system.file("exampleData", "catalog.xml", package = "XML")
>   xmlEventParse(fileName, handlers = list(startElement = startElement, endElement = endElement))
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "catalog"
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "group"
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "public"
ending public 
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "system"
ending system 
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "system"
ending system 
ending group 
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "uri"
ending uri 
<pointer: 0x7fa8f2d92ba0>
attr(,"class")
[1] "XMLParserContext"
[1] "rewriteURI"
Terminating parser
$startElement
function (ctxt, name, attrs, ...) 
{
    print(ctxt)
    print(name)
    if (name == "rewriteURI") {
        cat("Terminating parser\n")
        xmlStopParser(ctxt)
    }
}
attr(,"class")
[1] "XMLParserContextFunction"

$endElement
function (name, ...) 
cat("ending", name, "\n")

> 
> 
> 
> cleanEx()
> nameEx("xmlFlatListTree")
> ### * xmlFlatListTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlFlatListTree
> ### Title: Constructors for trees stored as flat list of nodes with
> ###   information about parents and children.
> ### Aliases: xmlFlatListTree xmlHashTree
> ### Keywords: IO
> 
> ### ** Examples
> 
>  f = system.file("exampleData", "dataframe.xml", package = "XML")
>  tr  = xmlHashTree()
>  xmlTreeParse(f, handlers = list(.startElement = tr[[".addNode"]]))
$.startElement
function (node, parent = character(), ..., attrs = NULL, namespace = NULL, 
    namespaceDefinitions = character(), .children = list(...), 
    cdata = FALSE, suppressNamespaceWarning = getOption("suppressXMLNamespaceWarning", 
        FALSE)) 
{
    if (is.character(node)) 
        node = xmlNode(node, attrs = attrs, namespace = namespace, 
            namespaceDefinitions = namespaceDefinitions)
    .kids = .children
    .children = .this$.children
    node = asXMLTreeNode(node, .this, className = "XMLHashTreeNode")
    id = node$id
    assign(id, node, env)
    .count <<- .count + 1
    if (!inherits(parent, "XMLNode") && (!is.environment(parent) && 
        length(parent) == 0) || parent == "") 
        return(node)
    if (inherits(parent, "XMLHashTreeNode")) 
        parent = parent$id
    if (length(parent)) {
        assign(id, parent, env = .parents)
        if (exists(parent, .children, inherits = FALSE)) 
            tmp = c(get(parent, .children), id)
        else tmp = id
        assign(parent, tmp, .children)
    }
    return(node)
}
<environment: 0x7fa8ed1f4d48>

> 
>  tr # print the tree on the screen
<A/>
> 
>   # Get the two child nodes of the dataframe node.
>  xmlChildren(tr$dataframe)
list()
> 
>   # Find the names of all the nodes.
>  objects(tr)
[1] "5"         "6"         "7"         "8"         "A"         "B"        
[7] "C"         "dataframe" "tr"       
>   # Which nodes have children
>  objects(tr$.children)
character(0)
> 
>   # Which nodes are leaves, i.e. do not have children
>  setdiff(objects(tr), objects(tr$.children))
[1] "5"         "6"         "7"         "8"         "A"         "B"        
[7] "C"         "dataframe" "tr"       
> 
>   # find the class of each of these leaf nodes.
>  sapply(setdiff(objects(tr), objects(tr$.children)),
+          function(id) class(tr[[id]]))
     5                  6                  7                 
[1,] "XMLHashTreeNode"  "XMLHashTreeNode"  "XMLHashTreeNode" 
[2,] "XMLNode"          "XMLNode"          "XMLNode"         
[3,] "RXMLAbstractNode" "RXMLAbstractNode" "RXMLAbstractNode"
[4,] "XMLAbstractNode"  "XMLAbstractNode"  "XMLAbstractNode" 
[5,] "oldClass"         "oldClass"         "oldClass"        
     8                  A                  B                 
[1,] "XMLHashTreeNode"  "XMLHashTreeNode"  "XMLHashTreeNode" 
[2,] "XMLNode"          "XMLNode"          "XMLNode"         
[3,] "RXMLAbstractNode" "RXMLAbstractNode" "RXMLAbstractNode"
[4,] "XMLAbstractNode"  "XMLAbstractNode"  "XMLAbstractNode" 
[5,] "oldClass"         "oldClass"         "oldClass"        
     C                  dataframe          tr                
[1,] "XMLHashTreeNode"  "XMLHashTreeNode"  "XMLHashTreeNode" 
[2,] "XMLNode"          "XMLNode"          "XMLNode"         
[3,] "RXMLAbstractNode" "RXMLAbstractNode" "RXMLAbstractNode"
[4,] "XMLAbstractNode"  "XMLAbstractNode"  "XMLAbstractNode" 
[5,] "oldClass"         "oldClass"         "oldClass"        
> 
>   # distribution of number of children
>  sapply(tr$.children, length)
named list()
> 
> 
>   # Get the first A node
>  tr$A
<A/>
> 
>   # Get is parent node.
>  xmlParent(tr$A)
NULL
> 
> 
>  f = system.file("exampleData", "allNodeTypes.xml", package = "XML")
> 
>    # Convert the document
>  r = xmlInternalTreeParse(f, xinclude = TRUE)
>  ht = as(r, "XMLHashTree")
>  ht
<top xmlns:r="http://wwww.r-project.org" xmlns:xi="http://www.w3.org/2003/XInclude">
 <doc>
  <!-- this is a very simple document to illustrate some elementary parsing -->
  <myNode/>
  <other>
</other>
  <last/>
 </doc>
 <r:a>
  <!-- A comment -->
  
  Some text
  
  <![CDATA[
  
    x < 1 && y > 2
    ]]>
  
 
 </r:a>
 <R/>
</top>
>  
>   # work on the root node, or any node actually
>  as(xmlRoot(r), "XMLHashTree")
<top xmlns:r="http://wwww.r-project.org" xmlns:xi="http://www.w3.org/2003/XInclude">
 <doc>
  <!-- this is a very simple document to illustrate some elementary parsing -->
  <myNode/>
  <other>
</other>
  <last/>
 </doc>
 <r:a>
  <!-- A comment -->
  
  Some text
  
  <![CDATA[
  
    x < 1 && y > 2
    ]]>
  
 
 </r:a>
 <R/>
</top>
> 
>   # Example of making copies of an XMLHashTreeNode object to create a separate tree.
>  f = system.file("exampleData", "simple.xml", package = "XML")
>  tt = as(xmlParse(f), "XMLHashTree")
> 
>  xmlRoot(tt)[[1]]
<b foo="bar">
 <c>
  <x>Some text</x>
 </c>
 <d/>
</b>
>  xmlRoot(tt)[[1, copy = TRUE]]
<b foo="bar">
 <c>
  <x>Some text</x>
 </c>
 <d/>
</b>
> 
>  table(unlist(eapply(tt, xmlName)))

   a    b    c    d    e    f    g text    x 
   1    1    1    1    1    1    1    1    1 
>  # if any of the nodes had any attributes
>  # table(unlist(eapply(tt, xmlAttrs)))
> 
> 
> 
> cleanEx()
> nameEx("xmlGetAttr")
> ### * xmlGetAttr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlGetAttr
> ### Title: Get the value of an attribute in an XML node
> ### Aliases: xmlGetAttr
> ### Keywords: file
> 
> ### ** Examples
> 
>  node <- xmlNode("foo", attrs=c(a="1", b="my name"))
> 
>  xmlGetAttr(node, "a")
[1] "1"
>  xmlGetAttr(node, "doesn't exist", "My own default value")
[1] "My own default value"
> 
>  xmlGetAttr(node, "b", "Just in case")
[1] "my name"
> 
> 
> 
> cleanEx()
> nameEx("xmlHandler")
> ### * xmlHandler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlHandler
> ### Title: Example XML Event Parser Handler Functions
> ### Aliases: xmlHandler
> ### Keywords: file IO
> 
> ### ** Examples
> 
> ## Not run: 
> ##D xmlURL <- "http://www.omegahat.org/Scripts/Data/mtcars.xml"
> ##D xmlText <- paste(scan(xmlURL, what="", sep="\n"),"\n",collapse="\n")
> ## End(Not run)
> 
> xmlURL <- system.file("exampleData", "mtcars.xml", package="XML")
> xmlText <- paste(readLines(xmlURL), "\n", collapse="")
> xmlEventParse(xmlText, handlers = NULL, asText=TRUE)
> xmlEventParse(xmlText, xmlHandler(), useTagName=TRUE, asText=TRUE)
comment  Taken from the R distribution, in turn taken from Henderson and Velleman 1981,  
     Building multiple regression models interactively, Biometrics 37 391-411 .   
 
MyText:  
MyText:  
MyText: mpg 
MyText:  
MyText: cyl 
MyText:  
MyText: disp 
MyText:  
MyText: hp 
MyText:  
MyText: drat 
MyText:  
MyText: wt 
MyText:  
MyText: qsec 
MyText:  
MyText: vs 
MyText:  
MyText: am 
MyText:  
MyText: gear 
MyText:  
MyText: carb 
MyText:  
MyText:  
MyText: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 
MyText:  
MyText: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 
MyText:  
MyText: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 
MyText:  
MyText: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 
MyText:  
MyText: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 
MyText:  
MyText: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 
MyText:  
MyText: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 
MyText:  
MyText: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 
MyText:  
MyText: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 
MyText:  
MyText: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 
MyText:  
MyText: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 
MyText:  
MyText: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 
MyText:  
MyText: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 
MyText:  
MyText: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 
MyText:  
MyText: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 
MyText:  
MyText: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 
MyText:  
MyText: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 
MyText:  
MyText: 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 
MyText:  
MyText: 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 
MyText:  
MyText: 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 
MyText:  
MyText: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 
MyText:  
MyText: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 
MyText:  
MyText: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 
MyText:  
MyText: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 
MyText:  
MyText: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 
MyText:  
MyText: 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 
MyText:  
MyText: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 
MyText:  
MyText: 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 
MyText:  
MyText: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 
MyText:  
MyText: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 
MyText:  
MyText: 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 
MyText:  
MyText: 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 
MyText:  
$startElement
function (name, atts, ...) 
{
    if (is.null(atts)) 
        atts <- list()
    data[[name]] <<- atts
}
<environment: 0x7fa8edf5a5c0>

$getData
function () 
{
    data
}
<environment: 0x7fa8edf5a5c0>

$comment
function (x, ...) 
{
    cat("comment", x, "\n")
}
<environment: 0x7fa8edf5a5c0>

$externalEntity
function (ctxt, baseURI, sysId, publicId, ...) 
{
    cat("externalEntity", ctxt, baseURI, sysId, publicId, "\n")
}
<environment: 0x7fa8edf5a5c0>

$entityDeclaration
function (name, baseURI, sysId, publicId, notation, ...) 
{
    cat("externalEntity", name, baseURI, sysId, publicId, notation, 
        "\n")
}
<environment: 0x7fa8edf5a5c0>

$text
function (x, ...) 
{
    cat("MyText:", x, "\n")
}
<environment: 0x7fa8edf5a5c0>

$foo
function (x, attrs, ...) 
{
    cat("In foo\n")
}
<environment: 0x7fa8edf5a5c0>

> 
> 
> 
> cleanEx()
> nameEx("xmlName")
> ### * xmlName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlName
> ### Title: Extraces the tag name of an XMLNode object.
> ### Aliases: xmlName xmlName<- xmlName.XMLComment xmlName.XMLNode
> ###   xmlName.XMLInternalNode
> ### Keywords: file
> 
> ### ** Examples
> 
>  fileName <- system.file("exampleData", "test.xml", package="XML") 
>  doc <- xmlTreeParse(fileName)
>  xmlName(xmlRoot(doc)[[1]])
[1] "element"
> 
>  tt = xmlRoot(doc)[[1]]
>  xmlName(tt)
[1] "element"
>  xmlName(tt) <- "bob"
> 
> 
>   # We can set the node on an internal object also.
>  n = newXMLNode("x")
> 
>  xmlName(n)
[1] "x"
>  xmlName(n) <- "y"
> 
>  
>  xmlName(n) <- "r:y"
> 
> 
> 
> 
> cleanEx()
> nameEx("xmlNamespace")
> ### * xmlNamespace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlNamespace
> ### Title: Retrieve the namespace value of an XML node.
> ### Aliases: xmlNamespace xmlNamespace.XMLNode xmlNamespace.XMLInternalNode
> ###   xmlNamespace.character XMLNamespace-class xmlNamespace<-
> ###   xmlNamespace<-,XMLInternalNode-method
> ### Keywords: file
> 
> ### ** Examples
> 
>   doc <- xmlTreeParse(system.file("exampleData", "job.xml", package="XML"))
>   xmlNamespace(xmlRoot(doc))
[1] "gjob"
attr(,"class")
[1] "XMLNamespacePrefix"
>   xmlNamespace(xmlRoot(doc)[[1]][[1]])
[1] "gjob"
attr(,"class")
[1] "XMLNamespacePrefix"
> 
> 
>   doc <- xmlInternalTreeParse(system.file("exampleData", "job.xml", package="XML"))
>      # Since the first node, xmlRoot() will skip that, by default.
>   xmlNamespace(xmlRoot(doc))
                                gjob 
"http://www.gnome.org/some-location" 
attr(,"class")
[1] "XMLNamespace"
>   xmlNamespace(xmlRoot(doc)[[1]][[1]])
                                gjob 
"http://www.gnome.org/some-location" 
attr(,"class")
[1] "XMLNamespace"
> 
>   node <- xmlNode("arg", xmlNode("name", "foo"), namespace="R")
>   xmlNamespace(node)
[1] "R"
> 
> 
>    doc = xmlParse('<top xmlns:r="http://www.r-project.org"><bob><code>a = 1:10</code></bob></top>')
>    node = xmlRoot(doc)[[1]][[1]]
>    xmlNamespace(node) = "r"
>    node
<r:code>a = 1:10</r:code> 
> 
> 
>    doc = xmlParse('<top xmlns:r="http://www.r-project.org"><bob><code>a = 1:10</code></bob></top>')
>    node = xmlRoot(doc)[[1]][[1]]
>    xmlNamespaces(node, set = TRUE) = c(omg = "http://www.omegahat.org")
>    node
<omg:code xmlns:omg="http://www.omegahat.org">a = 1:10</omg:code> 
> 
> 
> 
> cleanEx()
> nameEx("xmlNamespaceDefinitions")
> ### * xmlNamespaceDefinitions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlNamespaceDefinitions
> ### Title: Get definitions of any namespaces defined in this XML node
> ### Aliases: xmlNamespaceDefinitions getDefaultNamespace xmlNamespaces
> ###   xmlNamespaces<- xmlNamespaces<-,XMLInternalNode-method
> ###   xmlNamespaces<-,XMLNode-method
> ###   coerce,NULL,XMLNamespaceDefinitions-method
> ###   coerce,XMLNamespace,character-method
> ###   coerce,XMLNamespaceDefinition,character-method
> ###   coerce,XMLNamespaceDefinitions,character-method
> ###   coerce,character,XMLNamespaceDefinitions-method
> ### Keywords: IO
> 
> ### ** Examples
> 
>   f = system.file("exampleData", "longitudinalData.xml", package = "XML")
>   n = xmlRoot(xmlTreeParse(f))
>   xmlNamespaceDefinitions(n)
$rs
$id
[1] "rs"

$uri
[1] "http://www.omegahat.org/RSXML"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$lgtdl
$id
[1] "lgtdl"

$uri
[1] "http://www.r-project.org/XML/lgtdl"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

attr(,"class")
[1] "XMLNamespaceDefinitions"
>   xmlNamespaceDefinitions(n, recursive = TRUE)
$rs
$id
[1] "rs"

$uri
[1] "http://www.omegahat.org/RSXML"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$lgtdl
$id
[1] "lgtdl"

$uri
[1] "http://www.r-project.org/XML/lgtdl"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

attr(,"class")
[1] "XMLNamespaceDefinitions"
> 
> 
>     # Now using internal nodes.
>   f = system.file("exampleData", "namespaces.xml", package = "XML")
>   doc = xmlInternalTreeParse(f)
>   n = xmlRoot(doc)
>   xmlNamespaceDefinitions(n)
[[1]]
$id
[1] ""

$uri
[1] "http://www.omegahat.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$omegahat
$id
[1] "omegahat"

$uri
[1] "http://www.omegahat.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$r
$id
[1] "r"

$uri
[1] "http://www.r-project.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

attr(,"class")
[1] "XMLNamespaceDefinitions"
> 
>   xmlNamespaceDefinitions(n, recursive = TRUE)
[[1]]
$id
[1] ""

$uri
[1] "http://www.omegahat.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$omegahat
$id
[1] "omegahat"

$uri
[1] "http://www.omegahat.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$r
$id
[1] "r"

$uri
[1] "http://www.r-project.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

$c
$id
[1] "c"

$uri
[1] "http://www.c.org"

$local
[1] TRUE

attr(,"class")
[1] "XMLNamespaceDefinition"

attr(,"class")
[1] "XMLNamespaceDefinitions"
> 
> 
> 
> cleanEx()
> nameEx("xmlNode")
> ### * xmlNode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlNode
> ### Title: Create an XML node
> ### Aliases: xmlNode xmlTextNode xmlPINode xmlCDataNode xmlCommentNode
> ### Keywords: file
> 
> ### ** Examples
> 
> 
>  # node named arg with two children: name and defaultValue
>  # Both of these have a text node as their child.
>  n <- xmlNode("arg", attrs = c(default="TRUE"),
+                xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))
> 
> 
>   # internal C-level node.
>  a = newXMLNode("arg", attrs = c(default = "TRUE"),
+                 newXMLNode("name", "foo"),
+                 newXMLNode("defaultValue", "1:10"))
> 
>  xmlAttrs(a) = c(a = 1, b = "a string")
> 
>  xmlAttrs(a) = c(a = 1, b = "a string", append = FALSE)
> 
>  newXMLNamespace(a, c("r" = "http://www.r-project.org"))
<pointer: 0x7fa8f05b6230>
attr(,"class")
[1] "XMLNamespaceRef"
>  xmlAttrs(a) = c("r:class" = "character") 
> 
> 
>  xmlAttrs(a[[1]]) = c("r:class" = "character") 
> 
> 
>   # Using a character vector as a namespace definitions
>  x = xmlNode("bob",
+              namespaceDefinitions = c(r = "http://www.r-project.org",
+                                       omg = "http://www.omegahat.org"))
> 
> 
> 
> cleanEx()
> nameEx("xmlOutput")
> ### * xmlOutput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlOutputBuffer
> ### Title: XML output streams
> ### Aliases: xmlOutputBuffer xmlOutputDOM
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  con <- xmlOutputDOM()
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> con$addTag("author", "Duncan Temple Lang")
> con$addTag("address",  close=FALSE)
>  con$addTag("office", "2C-259")
>  con$addTag("street", "Mountain Avenue.")
>  con$addTag("phone", close = FALSE)
>    con$addTag("area", "908", attrs=c(state="NJ"))
>    con$addTag("number", "582-3217")
>  con$closeTag() # phone
> con$closeTag() # address
> 
> con$addTag("section", close = FALSE)
>  con$addNode(xmlTextNode("This is some text "))
>  con$addTag("a","and a link", attrs=c(href="http://www.omegahat.org"))
>  con$addNode(xmlTextNode("and some follow up text"))
> 
>  con$addTag("subsection", close = FALSE)
>    con$addNode(xmlTextNode("some addtional text "))
>    con$addTag("a", attrs=c(href="http://www.omegahat.org"), close=FALSE)
>      con$addNode(xmlTextNode("the content of the link"))
>    con$closeTag() # a
>  con$closeTag() # "subsection"
> con$closeTag() # section
> 
> 
>  d <- xmlOutputDOM()
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
>  d$addPI("S", "plot(1:10)")
>  d$addCData('x <- list(1, a="&");\nx[[2]]')
>  d$addComment("A comment")
>  print(d$value())
<doc>
 <?S plot(1:10)?>
 <![CDATA[
 x <- list(1, a="&");
x[[2]] ]]>
 <!--A comment-->
</doc>
>  print(d$value(), indent = FALSE, tagSeparator = "")
<doc><?S plot(1:10)?><![CDATA[x <- list(1, a="&");
x[[2]]]]><!--A comment--></doc>> 
> 
>  d = xmlOutputDOM("bob", xmlDeclaration = TRUE)
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
>  print(d$value())
<?xml version = "1.0"?>
<bob/>
> 
>  d = xmlOutputDOM("bob", xmlDeclaration = "encoding='UTF-8'")
Warning in names(ans) = names(con) :
  Class 'XMLOutputDOM' has no 'names' slot; assigning a names attribute will create an invalid object
>  print(d$value())
<?xml encoding='UTF-8' version='1.0'?>
<bob/>
> 
> 
>  d = xmlOutputBuffer("bob", header = "<?xml version='1.0' encoding='UTF-8'?>", 
+                       dtd = "foo.dtd")
Warning in names(ans) = names(con) :
  Class 'XMLOutputBuffer' has no 'names' slot; assigning a names attribute will create an invalid object
>  d$addTag("bob")
NULL
>  cat(d$value())
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE bob SYSTEM "foo.dtd"  >
<bob:bob></bob:bob>
> 
> 
> 
> cleanEx()
> nameEx("xmlParent")
> ### * xmlParent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlParent
> ### Title: Get parent node of XMLInternalNode or ancestor nodes
> ### Aliases: xmlParent xmlAncestors xmlParent.XMLInternalNode
> ###   xmlParent,XMLInternalNode-method xmlParent,XMLHashTreeNode-method
> ###   xmlParent,XMLTreeNode-method
> ### Keywords: file IO
> 
> ### ** Examples
> 
> 
>   top = newXMLNode("doc")
>   s = newXMLNode("section", attr = c(title = "Introduction"))
>   a = newXMLNode("article", s)
>   addChildren(top, a)
<doc>
  <article>
    <section>Introduction</section>
  </article>
</doc> 
> 
>   xmlName(xmlParent(s))
[1] "article"
>   xmlName(xmlParent(xmlParent(s)))
[1] "doc"
> 
> 
>     # Find the root node.
>   root = a
>   while(!is.null(xmlParent(root)))
+       root = xmlParent(root)
> 
>    # find the names of the parent nodes of each 'h' node.
>    # use a global variable to "simplify" things and not use a closure.
> 
>   filename = system.file("exampleData", "branch.xml", package = "XML")
>   parentNames <- character()
>   xmlParse(filename,
+                 handlers =
+                   list(h = function(x) {
+                    parentNames <<- c(parentNames, xmlName(xmlParent(x)))
+                   }))
$h
function (x) 
{
    parentNames <<- c(parentNames, xmlName(xmlParent(x)))
}

> 
>   table(parentNames)
parentNames
f 
4 
> 
> 
> 
> cleanEx()
> nameEx("xmlParseDoc")
> ### * xmlParseDoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlParseDoc
> ### Title: Parse an XML document with options controlling the parser.
> ### Aliases: xmlParseDoc COMPACT DTDATTR DTDLOAD DTDVALID HUGE NOBASEFIX
> ###   NOBLANKS NOCDATA NODICT NOENT NOERROR NONET NOWARNING NOXINCNODE
> ###   NSCLEAN OLDSAX PEDANTIC RECOVER XINCLUDE OLD10 SAX1
> ### Keywords: data
> 
> ### ** Examples
> 
>  f = system.file("exampleData", "mtcars.xml", package="XML")
>      # Same as xmlParse()
>  xmlParseDoc(f)
<?xml version="1.0"?>
<!DOCTYPE dataset SYSTEM "../DatasetByRecord.dtd">
<!-- Taken from the R distribution, in turn taken from Henderson and Velleman 1981, 
     Building multiple regression models interactively, Biometrics 37 391-411 .  
-->
<dataset name="mtcars" numRecords="32" source="R Project">
 <variables count="11">
    <variable unit="Miles/gallon">mpg</variable> 
    <variable>cyl</variable>  
    <variable>disp</variable> 
    <variable>hp</variable> 
    <variable>drat</variable>
    <variable>wt</variable>
    <variable>qsec</variable>
    <variable>vs</variable>
    <variable type="FactorVariable" levels="automatic,manual">am</variable>
    <variable>gear</variable>
    <variable>carb</variable>
  </variables>
 <record id="Mazda RX4">   21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</record>
 <record id="Mazda RX4 Wag"> 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4</record>
 <record id="Datsun 710">  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</record>
 <record id="Hornet 4 Drive">      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1</record>
 <record id="Hornet Sportabout">   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</record>
 <record id="Valiant">             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1</record>
 <record id="Duster 360">          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</record>
 <record id="Merc 240D">           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</record>
 <record id="Merc 230">            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2</record>
 <record id="Merc 280">            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</record>
 <record id="Merc 280C">           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4</record>
 <record id="Merc 450SE">          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</record>
 <record id="Merc 450SL">          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</record>
 <record id="Merc 450SLC">         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</record>
 <record id="Cadillac Fleetwood">  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</record>
 <record id="Lincoln Continental"> 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</record>
 <record id="Chrysler Imperial">   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</record>
 <record id="Fiat 128">            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</record>
 <record id="Honda Civic">         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</record>
 <record id="Toyota Corolla">      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</record>
 <record id="Toyota Corona">       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1</record>
 <record id="Dodge Challenger">    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2</record>
 <record id="AMC Javelin">         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2</record>
 <record id="Camaro Z28">          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</record>
 <record id="Pontiac Firebird">    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</record>
 <record id="Fiat X1-9">           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</record>
 <record id="Porsche 914-2">       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</record>
 <record id="Lotus Europa">        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</record>
 <record id="Ford Pantera L">      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</record>
 <record id="Ferrari Dino">        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</record>
 <record id="Maserati Bora">       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</record>
 <record id="Volvo 142E">          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</record>
</dataset>
 
> 
>  txt =
+      '<top xmlns:r="http://www.r-project.org">
+         <b xmlns:r="http://www.r-project.org">
+           <c xmlns:omg="http:/www.omegahat.org"/>
+         </b>
+       </top>'
> 
>  xmlParseDoc(txt,  NSCLEAN, asText = TRUE)
<?xml version="1.0"?>
<top xmlns:r="http://www.r-project.org">
        <b>
          <c xmlns:omg="http:/www.omegahat.org"/>
        </b>
      </top>
 
> 
>  txt =
+      '<top xmlns:r="http://www.r-project.org"  xmlns:r="http://www.r-project.org">
+         <b xmlns:r="http://www.r-project.org">
+           <c xmlns:omg="http:/www.omegahat.org"/>
+         </b>
+       </top>'
> 
>  xmlParseDoc(txt, c(NSCLEAN, NOERROR), asText = TRUE)
NULL
> 
> 
> 
> cleanEx()
> nameEx("xmlRoot")
> ### * xmlRoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlRoot
> ### Title: Get the top-level XML node.
> ### Aliases: xmlRoot xmlRoot.XMLDocument xmlRoot.XMLInternalDocument
> ###   xmlRoot.XMLInternalDOM xmlRoot.XMLDocumentRoot
> ###   xmlRoot.XMLDocumentContent xmlRoot.HTMLDocument
> ### Keywords: file
> 
> ### ** Examples
> 
>   doc <- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
>   xmlRoot(doc)
<dataset name="mtcars" numRecords="32" source="R Project">
 <variables count="11">
  <variable unit="Miles/gallon">mpg</variable>
  <variable>cyl</variable>
  <variable>disp</variable>
  <variable>hp</variable>
  <variable>drat</variable>
  <variable>wt</variable>
  <variable>qsec</variable>
  <variable>vs</variable>
  <variable type="FactorVariable" levels="automatic,manual">am</variable>
  <variable>gear</variable>
  <variable>carb</variable>
 </variables>
 <record id="Mazda RX4">21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</record>
 <record id="Mazda RX4 Wag">21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4</record>
 <record id="Datsun 710">22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</record>
 <record id="Hornet 4 Drive">21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1</record>
 <record id="Hornet Sportabout">18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2</record>
 <record id="Valiant">18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1</record>
 <record id="Duster 360">14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4</record>
 <record id="Merc 240D">24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</record>
 <record id="Merc 230">22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2</record>
 <record id="Merc 280">19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</record>
 <record id="Merc 280C">17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4</record>
 <record id="Merc 450SE">16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3</record>
 <record id="Merc 450SL">17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3</record>
 <record id="Merc 450SLC">15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3</record>
 <record id="Cadillac Fleetwood">10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4</record>
 <record id="Lincoln Continental">10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</record>
 <record id="Chrysler Imperial">14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4</record>
 <record id="Fiat 128">32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</record>
 <record id="Honda Civic">30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</record>
 <record id="Toyota Corolla">33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</record>
 <record id="Toyota Corona">21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1</record>
 <record id="Dodge Challenger">15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2</record>
 <record id="AMC Javelin">15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2</record>
 <record id="Camaro Z28">13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4</record>
 <record id="Pontiac Firebird">19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2</record>
 <record id="Fiat X1-9">27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</record>
 <record id="Porsche 914-2">26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</record>
 <record id="Lotus Europa">30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</record>
 <record id="Ford Pantera L">15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4</record>
 <record id="Ferrari Dino">19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6</record>
 <record id="Maserati Bora">15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8</record>
 <record id="Volvo 142E">21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</record>
</dataset>
>    # Note that we cannot use getSibling () on a regular R-level XMLNode object
>    # since we cannot go back up or across the tree from that node, but
>    # only down to the children.
> 
>     # Using an internal node via xmlParse (== xmlInternalTreeParse())
>   doc <- xmlParse(system.file("exampleData", "mtcars.xml", package="XML"))
>   n = xmlRoot(doc, skip = FALSE)
>      # skip over the DTD and the comment
>   d = getSibling(getSibling(n))
> 
> 
> 
> cleanEx()
> nameEx("xmlSchemaValidate")
> ### * xmlSchemaValidate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlSchemaValidate
> ### Title: Validate an XML document relative to an XML schema
> ### Aliases: xmlSchemaValidate schemaValidationErrorHandler
> ### Keywords: IO
> 
> ### ** Examples
> 
> if(FALSE) {
+   xsd = xmlParse(system.file("exampleData", "author.xsd", package = "XML"), isSchema =TRUE)
+   doc = xmlInternalTreeParse(system.file("exampleData", "author.xml",  package = "XML"))
+   xmlSchemaValidate(xsd, doc)
+ }
> 
> 
> 
> cleanEx()
> nameEx("xmlSerializeHook")
> ### * xmlSerializeHook
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlSerializeHook
> ### Title: Functions that help serialize and deserialize XML internal
> ###   objects
> ### Aliases: xmlSerializeHook xmlDeserializeHook
> ### Keywords: IO
> 
> ### ** Examples
> 
> z = newXMLNode("foo")
> f = system.file("exampleData", "tides.xml", package = "XML")
> doc = xmlParse(f)
> hdoc = as(doc, "XMLHashTree")
> 
> nodes = getNodeSet(doc, "//pred")
> 
> saveRDS(list(a = 1:10, z = z, doc = doc, hdoc = hdoc, nodes = nodes), "tmp.rda",
+           refhook = xmlSerializeHook)
> 
> v = readRDS("tmp.rda", refhook = xmlDeserializeHook)
> 
> 
> 
> cleanEx()
> nameEx("xmlSize")
> ### * xmlSize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlSize
> ### Title: The number of sub-elements within an XML node.
> ### Aliases: xmlSize xmlSize.default xmlSize.XMLDocument xmlSize.XMLNode
> ### Keywords: file
> 
> ### ** Examples
> 
>   fileName <- system.file("exampleData", "mtcars.xml", package="XML") 
>   doc <- xmlTreeParse(fileName)
>   xmlSize(doc)
[1] 2
>   xmlSize(doc$doc$children[["dataset"]][["variables"]])
[1] 11
> 
> 
> 
> cleanEx()
> nameEx("xmlSource")
> ### * xmlSource
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlSource
> ### Title: Source the R code, examples, etc. from an XML document
> ### Aliases: xmlSource xmlSource,character-method
> ###   xmlSource,XMLNodeSet-method xmlSource,XMLInternalDocument-method
> ###   xmlSourceFunctions xmlSourceFunctions,character-method
> ###   xmlSourceFunctions,XMLInternalDocument-method xmlSourceSection
> ###   xmlSourceSection,character-method
> ###   xmlSourceSection,XMLInternalDocument-method xmlSourceThread
> ###   xmlSourceThread,XMLInternalDocument-method
> ###   xmlSourceThread,character-method xmlSourceThread,list-method
> ### Keywords: IO programming
> 
> ### ** Examples
> 
>  xmlSource(system.file("exampleData", "Rsource.xml", package="XML"))
> 
>   # This illustrates using r:frag nodes.
>   # The r:frag nodes are not processed directly, but only
>   # if referenced in the contents/body of a r:code node
>  f = system.file("exampleData", "Rref.xml", package="XML")
>  xmlSource(f)
top-level code node
r:code node with id bob
[1] 10
> 
> 
> 
> cleanEx()
> nameEx("xmlStopParser")
> ### * xmlStopParser
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlStopParser
> ### Title: Terminate an XML parser
> ### Aliases: xmlStopParser
> ### Keywords: IO programming
> 
> ### ** Examples
> 
> 
>   ############################################
>   # Stopping the parser mid-way and an example of using XMLParserContextFunction.
> 
>   startElement =
+   function(ctxt, name, attrs, ...)  {
+     print(ctxt)
+       print(name)
+       if(name == "rewriteURI") {
+            cat("Terminating parser\n")
+ 	   xmlStopParser(ctxt)
+       }
+   }
>   class(startElement) = "XMLParserContextFunction"  
>   endElement =
+   function(name, ...) 
+     cat("ending", name, "\n")
> 
>   fileName = system.file("exampleData", "catalog.xml", package = "XML")
>   xmlEventParse(fileName, handlers = list(startElement = startElement, endElement = endElement))
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "catalog"
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "group"
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "public"
ending public 
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "system"
ending system 
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "system"
ending system 
ending group 
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "uri"
ending uri 
<pointer: 0x7fa8f2dbc850>
attr(,"class")
[1] "XMLParserContext"
[1] "rewriteURI"
Terminating parser
$startElement
function (ctxt, name, attrs, ...) 
{
    print(ctxt)
    print(name)
    if (name == "rewriteURI") {
        cat("Terminating parser\n")
        xmlStopParser(ctxt)
    }
}
attr(,"class")
[1] "XMLParserContextFunction"

$endElement
function (name, ...) 
cat("ending", name, "\n")

> 
> 
> 
> cleanEx()
> nameEx("xmlStructuredStop")
> ### * xmlStructuredStop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlStructuredStop
> ### Title: Condition/error handler functions for XML parsing
> ### Aliases: xmlStructuredStop xmlErrorCumulator
> ### Keywords: IO programming
> 
> ### ** Examples
> 
>   tryCatch( xmlTreeParse("<a><b></a>", asText = TRUE, error = NULL),
+                  XMLError = function(e) {
+                     cat("There was an error in the XML at line", 
+                           e$line, "column", e$col, "\n",
+                          e$message, "\n")
+                 })
There was an error in the XML at line 1 column 11 
 Opening and ending tag mismatch: b line 1 and a
 
> 
> 
> 
> cleanEx()
> nameEx("xmlSubset")
> ### * xmlSubset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: [.XMLNode
> ### Title: Convenience accessors for the children of XMLNode objects.
> ### Aliases: [.XMLNode [[.XMLNode [[.XMLInternalElementNode
> ###   [[.XMLDocumentContent
> ### Keywords: IO file
> 
> ### ** Examples
> 
> 
>  f = system.file("exampleData", "gnumeric.xml", package = "XML")
> 
>  top = xmlRoot(xmlTreeParse(f))
> 
>   # Get the first RowInfo element.
>  top[["Sheets"]][[1]][["Rows"]][["RowInfo"]]
<gmr:RowInfo No="1" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>
> 
>   # Get a list containing only the first row element
>  top[["Sheets"]][[1]][["Rows"]]["RowInfo"]
$RowInfo
<gmr:RowInfo No="1" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

attr(,"class")
[1] "XMLNodeList"
>  top[["Sheets"]][[1]][["Rows"]][1]
$RowInfo
<gmr:RowInfo No="1" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

attr(,"class")
[1] "XMLNodeList"
> 
>   # Get all of the RowInfo elements by position
>  top[["Sheets"]][[1]][["Rows"]][1:xmlSize(top[["Sheets"]][[1]][["Rows"]])]
$RowInfo
<gmr:RowInfo No="1" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="2" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="3" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="4" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="5" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="6" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="7" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

attr(,"class")
[1] "XMLNodeList"
> 
>   # But more succinctly and accurately, get all of the RowInfo elements
>  top[["Sheets"]][[1]][["Rows"]]["RowInfo", all = TRUE]
$RowInfo
<gmr:RowInfo No="1" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="2" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="3" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="4" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="5" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="6" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

$RowInfo
<gmr:RowInfo No="7" Unit="18.000000" MarginA="1.000000" MarginB="1.000000" HardSize="0"/>

attr(,"class")
[1] "XMLNodeList"
> 
> 
> 
> 
> cleanEx()
> nameEx("xmlToDataFrame")
> ### * xmlToDataFrame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlToDataFrame
> ### Title: Extract data from a simple XML document
> ### Aliases: xmlToDataFrame xmlToDataFrame,character,ANY,ANY,ANY,ANY-method
> ###   xmlToDataFrame,XMLInternalDocument,ANY,ANY,ANY,missing-method
> ###   xmlToDataFrame,ANY,ANY,ANY,ANY,XMLNodeSet-method
> ###   xmlToDataFrame,ANY,ANY,ANY,ANY,XMLInternalNodeList-method
> ###   xmlToDataFrame,ANY,ANY,ANY,ANY,list-method
> ###   xmlToDataFrame,XMLInternalNodeList,ANY,ANY,ANY,ANY-method
> ###   xmlToDataFrame,XMLNodeSet,ANY,ANY,ANY,ANY-method
> ###   xmlToDataFrame,list,ANY,ANY,ANY,ANY-method
> ### Keywords: IO
> 
> ### ** Examples
> 
>  f = system.file("exampleData", "size.xml", package = "XML")
>  xmlToDataFrame(f, c("integer", "integer", "numeric"))
  age sex number
1   0   0    500
2   0   1    300
3   1   0    200
4   1   1    400
5  10   0     NA
> 
>    # Drop the middle variable.
>  z = xmlToDataFrame(f, colClasses = list("integer", NULL, "numeric"))
> 
> 
>    #  This illustrates how we can get a subset of nodes and process
>    #  those as the "data nodes", ignoring the others.
>   f = system.file("exampleData", "tides.xml", package = "XML")
>   doc = xmlParse(f)
>   xmlToDataFrame(nodes = xmlChildren(xmlRoot(doc)[["data"]]))
        date day     time pred highlow
1 2010/11/13 Sat 06:08 AM 4.74       H
2 2010/11/13 Sat 11:52 AM 2.75       L
3 2010/11/13 Sat 04:50 PM 4.28       H
4 2010/11/13 Sat 11:36 PM 0.83       L
5 2010/11/14 Sun 06:49 AM 4.89       H
6 2010/11/14 Sun 12:56 PM  2.3       L
7 2010/11/14 Sun 06:07 PM 4.04       H
> 
>     # or, alternatively
>   xmlToDataFrame(nodes = getNodeSet(doc, "//data/item"))
        date day     time pred highlow
1 2010/11/13 Sat 06:08 AM 4.74       H
2 2010/11/13 Sat 11:52 AM 2.75       L
3 2010/11/13 Sat 04:50 PM 4.28       H
4 2010/11/13 Sat 11:36 PM 0.83       L
5 2010/11/14 Sun 06:49 AM 4.89       H
6 2010/11/14 Sun 12:56 PM  2.3       L
7 2010/11/14 Sun 06:07 PM 4.04       H
> 
> 
>   f = system.file("exampleData", "kiva_lender.xml", package = "XML")
>   doc = xmlParse(f)
>   dd = xmlToDataFrame(getNodeSet(doc, "//lender"))
Warning: closing unused connection 4 (/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/gnumeric.xml)
> 
> 
> 
> cleanEx()
> nameEx("xmlToList")
> ### * xmlToList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlToList
> ### Title: Convert an XML node/document to a more R-like list
> ### Aliases: xmlToList
> ### Keywords: IO data
> 
> ### ** Examples
> 
> tt = 
+  '<x>
+      <a>text</a>
+      <b foo="1"/>
+      <c bar="me">
+         <d>a phrase</d>
+      </c>
+   </x>'
> 
>   doc = xmlParse(tt)
>   xmlToList(doc)
$a
[1] "text"

$b
foo 
"1" 

$c
$c$d
[1] "a phrase"

$c$.attrs
 bar 
"me" 


> 
>    # use an R-level node representation
>   doc = xmlTreeParse(tt)
>   xmlToList(doc)
$a
[1] "text"

$b
foo 
"1" 

$c
$c$d
[1] "a phrase"

$c$.attrs
 bar 
"me" 


> 
> 
> 
> cleanEx()
> nameEx("xmlTree")
> ### * xmlTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlTree
> ### Title: An internal, updatable DOM object for building XML trees
> ### Aliases: xmlTree
> ### Keywords: IO
> 
> ### ** Examples
> 
> 
> z = xmlTree("people", namespaces = list(r = "http://www.r-project.org"))
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$setNamespace("r")
> 
> z$addNode("person", attrs = c(id = "123"), close = FALSE)
>   z$addNode("firstname", "Duncan")
>   z$addNode("surname", "Temple Lang")
>   z$addNode("title", "Associate Professor")
>   z$addNode("expertize", close = FALSE)
>      z$addNode("topic", "Data Technologies")
>      z$addNode("topic", "Programming Language Design")
>      z$addNode("topic", "Parallel Computing")
>      z$addNode("topic", "Data Visualization")
>      z$addNode("topic", "Meta-Computing")
>      z$addNode("topic", "Inter-system interfaces")
>   z$closeTag()
>   z$addNode("address", "4210 Mathematical Sciences Building, UC Davis")
> z$closeTag()
> 
>   tr <- xmlTree("CDataTest")
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
>   tr$addTag("top", close=FALSE)
>   tr$addCData("x <- list(1, a='&');\nx[[2]]")
>   tr$addPI("S", "plot(1:10)")
>   tr$closeTag()
>   cat(saveXML(tr$value()))
<?xml version="1.0"?>
<CDataTest>
  <top><![CDATA[x <- list(1, a='&');
x[[2]]]]></top>
</CDataTest>
> 
> 
>   f = tempfile()
>   saveXML(tr, f, encoding = "UTF-8")
[1] "/var/folders/f8/2dd5rdyx1bjbw4jttt0x1hm80000gn/T//RtmptuGCKQ/file8c462afeaea9"
> 
> 
>   # Creating a node
> x = rnorm(3)
> z = xmlTree("r:data", namespaces = c(r = "http://www.r-project.org"))
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$addNode("numeric", attrs = c("r:length" = length(x)))
> 
> 
>   # shows namespace prefix on an attribute, and different from the one on the node.
>   z = xmlTree()
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$addNode("r:data",  namespace = c(r = "http://www.r-project.org", omg = "http://www.omegahat.org"), close = FALSE)
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
> x = rnorm(3)
> z$addNode("r:numeric", attrs = c("omg:length" = length(x)))
> 
> 
> z = xmlTree("examples")
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> z$addNode("example", namespace = list(r = "http://www.r-project.org"), close = FALSE)
> z$addNode("code", "mean(rnorm(100))", namespace = "r")
> 
> 
> x = summary(rnorm(1000))
> d = xmlTree()
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> d$addNode("table", close = FALSE)
Warning in xmlRoot.XMLInternalDocument(currentNodes[[1]]) :
  empty XML document
> 
> d$addNode("tr", .children = sapply(names(x), function(x) d$addNode("th", x)))
> d$addNode("tr", .children = sapply(x, function(x) d$addNode("td", format(x))))
> 
> d$closeNode()
> cat(saveXML(d))
<?xml version="1.0"?>

<table>
  <tr>
    <th>Min.</th>
    <th>1st Qu.</th>
    <th>Median</th>
    <th>Mean</th>
    <th>3rd Qu.</th>
    <th>Max.</th>
  </tr>
  <tr>
    <td>-3.008</td>
    <td>-0.6974</td>
    <td>-0.03132</td>
    <td>-0.01148</td>
    <td>0.6893</td>
    <td>3.81</td>
  </tr>
</table>> 
> # Dealing with DTDs and system and public identifiers for DTDs.
> # Just doctype
> za = xmlTree("people", dtd = "people")
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> # no public element
> zb = xmlTree("people", dtd = c("people", "", "http://www.omegahat.org/XML/types.dtd"))
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> # public and system
> zc = xmlTree("people", dtd = c("people", "//a//b//c//d", "http://www.omegahat.org/XML/types.dtd"))
Warning in names(ans) = names(v) :
  Class 'XMLInternalDOM' has no 'names' slot; assigning a names attribute will create an invalid object
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("xmlTreeParse")
> ### * xmlTreeParse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlTreeParse
> ### Title: XML Parser
> ### Aliases: xmlTreeParse htmlTreeParse htmlParse xmlInternalTreeParse
> ###   xmlNativeTreeParse xmlParse xmlSchemaParse
> ### Keywords: file IO
> 
> ### ** Examples
> 
>  fileName <- system.file("exampleData", "test.xml", package="XML")
>    # parse the document and return it in its standard format.
> 
>  xmlTreeParse(fileName)
$doc
$file
[1] "/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/test.xml"

$version
[1] "1.0"

$children
$children$comment
<!--A comment-->

$children$foo
<foo x="1">
 <element attrib1="my value"/>
  test entity bar <?R sum(rnorm(100))?>
 <a>
  <!--A comment-->
  <b>%extEnt;</b>
 </a>
 <![CDATA[
 This is escaped data
 containing < and &. ]]>
 Note that this caused a segmentation fault if replaceEntities was 
not TRUE.
That is,
 <code>xmlTreeParse(&quot;test.xml&quot;, replaceEntities = TRUE)</code>
 works, but
 <code>xmlTreeParse(&quot;test.xml&quot;)</code>
 does not if this is called before the one above.
This is now fixed and was caused by
treating an xmlNodePtr in the C code 
that had type XML_ELEMENT_DECL
and so was in fact an xmlElementPtr.
Aaah, C and casting!
</foo>


attr(,"class")
[1] "XMLDocumentContent"

$dtd
$external
NULL

$internal
$elements
$elements$x
$name
[1] "x"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$y
$name
[1] "y"

$type
element 
     15 

$contents
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"


$entities
$entities$testEnt
$name
[1] "testEnt"

$value
[1] "test entity bar"

$original
[1] "test entity bar"

attr(,"class")
[1] "XMLEntity"

$entities$logo
$name
[1] "logo"

$value
[1] "gif"

$original
NULL

attr(,"class")
[1] "XMLEntity"


attr(,"class")
[1] "InternalDTD"

attr(,"class")
[1] "DTDList"

attr(,"class")
[1] "XMLDocument"         "XMLAbstractDocument" "oldClass"           
> 
>    # parse the document, discarding comments.
>   
>  xmlTreeParse(fileName, handlers=list("comment"=function(x,...){NULL}), asTree = TRUE)
$doc
$file
[1] "/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/test.xml"

$version
[1] "1.0"

$children
$children$foo
<foo x="1">
 <element attrib1="my value"/>
  test entity bar <?R sum(rnorm(100))?>
 <a>
  <b>%extEnt;</b>
 </a>
 <![CDATA[
 This is escaped data
 containing < and &. ]]>
 Note that this caused a segmentation fault if replaceEntities was 
not TRUE.
That is,
 <code>xmlTreeParse(&quot;test.xml&quot;, replaceEntities = TRUE)</code>
 works, but
 <code>xmlTreeParse(&quot;test.xml&quot;)</code>
 does not if this is called before the one above.
This is now fixed and was caused by
treating an xmlNodePtr in the C code 
that had type XML_ELEMENT_DECL
and so was in fact an xmlElementPtr.
Aaah, C and casting!
</foo>


attr(,"class")
[1] "XMLDocumentContent"

$dtd
$external
NULL

$internal
$elements
$elements$x
$name
[1] "x"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$y
$name
[1] "y"

$type
element 
     15 

$contents
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"


$entities
$entities$testEnt
$name
[1] "testEnt"

$value
[1] "test entity bar"

$original
[1] "test entity bar"

attr(,"class")
[1] "XMLEntity"

$entities$logo
$name
[1] "logo"

$value
[1] "gif"

$original
NULL

attr(,"class")
[1] "XMLEntity"


attr(,"class")
[1] "InternalDTD"

attr(,"class")
[1] "DTDList"

attr(,"class")
[1] "XMLDocument"         "XMLAbstractDocument" "oldClass"           
> 
>    # print the entities
>  invisible(xmlTreeParse(fileName,
+             handlers=list(entity=function(x) {
+                                     cat("In entity",x$name, x$value,"\n")
+                                     x}
+                                   ), asTree = TRUE
+                           )
+           )
In entity testEnt test entity bar 
> 
>  # Parse some XML text.
>  # Read the text from the file
>  xmlText <- paste(readLines(fileName), "\n", collapse="")
> 
>  print(xmlText)
[1] "<?xml version=\"1.0\" ?> \n<!DOCTYPE foo [ \n  <!ENTITY % bar \"for R and S\"> \n  <!ENTITY % foo \"for Omegahat\"> \n \n  <!ENTITY testEnt \"test entity bar\"> \n  <!ENTITY logo SYSTEM \"images/logo.gif\" NDATA gif> \n  <!ENTITY % extEnt SYSTEM \"http://www.omegahat.org\">   <!-- include the contents of the README file in the same directory as this one. --> \n \n  <!ELEMENT x  (#PCDATA) > \n  <!ELEMENT y  (x)* > \n]> \n<!-- A comment --> \n<foo x=\"1\"> \n <element attrib1=\"my value\" /> \n &testEnt; \n <?R sum(rnorm(100)) ?> \n <a> \n  <!-- A comment --> \n  <b>  \n    %extEnt; \n  </b> \n </a> \n<![CDATA[ \n This is escaped data \n containing < and &. \n]]> \n \nNote that this caused a segmentation fault if replaceEntities was  \nnot TRUE. \nThat is, \n<code> \nxmlTreeParse(\"test.xml\", replaceEntities = TRUE) \n</code> \nworks, but  \n<code> \nxmlTreeParse(\"test.xml\") \n</code> \ndoes not if this is called before the one above. \nThis is now fixed and was caused by \ntreating an xmlNodePtr in the C code  \nthat had type XML_ELEMENT_DECL \nand so was in fact an xmlElementPtr. \nAaah, C and casting! \n</foo> \n"
>  xmlTreeParse(xmlText, asText=TRUE)
$doc
$file
[1] "<buffer>"

$version
[1] "1.0"

$children
$children$comment
<!--A comment-->

$children$foo
<foo x="1">
 <element attrib1="my value"/>
  test entity bar <?R sum(rnorm(100))?>
 <a>
  <!--A comment-->
  <b>%extEnt;</b>
 </a>
 <![CDATA[
 This is escaped data 
 containing < and &. ]]>
 Note that this caused a segmentation fault if replaceEntities was  
not TRUE. 
That is,
 <code>xmlTreeParse(&quot;test.xml&quot;, replaceEntities = TRUE)</code>
 works, but
 <code>xmlTreeParse(&quot;test.xml&quot;)</code>
 does not if this is called before the one above. 
This is now fixed and was caused by 
treating an xmlNodePtr in the C code  
that had type XML_ELEMENT_DECL 
and so was in fact an xmlElementPtr. 
Aaah, C and casting!
</foo>


attr(,"class")
[1] "XMLDocumentContent"

$dtd
$external
NULL

$internal
$elements
$elements$x
$name
[1] "x"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$y
$name
[1] "y"

$type
element 
     15 

$contents
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"


$entities
$entities$testEnt
$name
[1] "testEnt"

$value
[1] "test entity bar"

$original
[1] "test entity bar"

attr(,"class")
[1] "XMLEntity"

$entities$logo
$name
[1] "logo"

$value
[1] "gif"

$original
NULL

attr(,"class")
[1] "XMLEntity"


attr(,"class")
[1] "InternalDTD"

attr(,"class")
[1] "DTDList"

attr(,"class")
[1] "XMLDocument"         "XMLAbstractDocument" "oldClass"           
> 
> 
>     # with version 1.4.2 we can pass the contents of an XML
>     # stream without pasting them.
>  xmlTreeParse(readLines(fileName), asText=TRUE)
$doc
$file
[1] "<buffer>"

$version
[1] "1.0"

$children
$children$comment
<!--A comment-->

$children$foo
<foo x="1">
 <element attrib1="my value"/>
  test entity bar <?R sum(rnorm(100))?>
 <a>
  <!--A comment-->
  <b>%extEnt;</b>
 </a>
 <![CDATA[
 This is escaped data
 containing < and &. ]]>
 Note that this caused a segmentation fault if replaceEntities was 
not TRUE.
That is,
 <code>xmlTreeParse(&quot;test.xml&quot;, replaceEntities = TRUE)</code>
 works, but
 <code>xmlTreeParse(&quot;test.xml&quot;)</code>
 does not if this is called before the one above.
This is now fixed and was caused by
treating an xmlNodePtr in the C code 
that had type XML_ELEMENT_DECL
and so was in fact an xmlElementPtr.
Aaah, C and casting!
</foo>


attr(,"class")
[1] "XMLDocumentContent"

$dtd
$external
NULL

$internal
$elements
$elements$x
$name
[1] "x"

$type
mixed 
   15 

$contents
$type
PCData 
     1 

$ocur
Once 
   1 

$elements
NULL

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$y
$name
[1] "y"

$type
element 
     15 

$contents
$type
Element 
      2 

$ocur
Mult 
   3 

$elements
[1] "x"

attr(,"class")
[1] "XMLElementContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"


$entities
$entities$testEnt
$name
[1] "testEnt"

$value
[1] "test entity bar"

$original
[1] "test entity bar"

attr(,"class")
[1] "XMLEntity"

$entities$logo
$name
[1] "logo"

$value
[1] "gif"

$original
NULL

attr(,"class")
[1] "XMLEntity"


attr(,"class")
[1] "InternalDTD"

attr(,"class")
[1] "DTDList"

attr(,"class")
[1] "XMLDocument"         "XMLAbstractDocument" "oldClass"           
> 
> 
>  # Read a MathML document and convert each node
>  # so that the primary class is 
>  #   <name of tag>MathML
>  # so that we can use method  dispatching when processing
>  # it rather than conditional statements on the tag name.
>  # See plotMathML() in examples/.
>  fileName <- system.file("exampleData", "mathml.xml",package="XML")
> m <- xmlTreeParse(fileName, 
+                   handlers=list(
+                    startElement = function(node){
+                    cname <- paste(xmlName(node),"MathML", sep="",collapse="")
+                    class(node) <- c(cname, class(node)); 
+                    node
+                 }))
> 
> 
> 
>   # In this example, we extract _just_ the names of the
>   # variables in the mtcars.xml file. 
>   # The names are the contents of the <variable>
>   # tags. We discard all other tags by returning NULL
>   # from the startElement handler.
>   #
>   # We cumulate the names of variables in a character
>   # vector named `vars'.
>   # We define this within a closure and define the 
>   # variable function within that closure so that it
>   # will be invoked when the parser encounters a <variable>
>   # tag.
>   # This is called with 2 arguments: the XMLNode object (containing
>   # its children) and the list of attributes.
>   # We get the variable name via call to xmlValue().
> 
>   # Note that we define the closure function in the call and then 
>   # create an instance of it by calling it directly as
>   #   (function() {...})()
> 
>   # Note that we can get the names by parsing
>   # in the usual manner and the entire document and then executing
>   # xmlSApply(xmlRoot(doc)[[1]], function(x) xmlValue(x[[1]]))
>   # which is simpler but is more costly in terms of memory.
>  fileName <- system.file("exampleData", "mtcars.xml", package="XML")
>  doc <- xmlTreeParse(fileName,  handlers = (function() { 
+                                  vars <- character(0) ;
+                                 list(variable=function(x, attrs) { 
+                                                 vars <<- c(vars, xmlValue(x[[1]])); 
+                                                 NULL}, 
+                                      startElement=function(x,attr){
+                                                    NULL
+                                                   }, 
+                                      names = function() {
+                                                  vars
+                                              }
+                                     )
+                                })()
+                      )
> 
>   # Here we just print the variable names to the console
>   # with a special handler.
>  doc <- xmlTreeParse(fileName, handlers = list(
+                                   variable=function(x, attrs) {
+                                              print(xmlValue(x[[1]])); TRUE
+                                            }), asTree=TRUE)
[1] "mpg"
[1] "cyl"
[1] "disp"
[1] "hp"
[1] "drat"
[1] "wt"
[1] "qsec"
[1] "vs"
[1] "am"
[1] "gear"
[1] "carb"
> 
> 
>   # This should raise an error.
>   try(xmlTreeParse(
+             system.file("exampleData", "TestInvalid.xml", package="XML"),
+             validate=TRUE))
Element title was declared EMPTY this one has content
Element doc content does not follow the DTD, expecting (title , version), got (title )
$doc
$file
[1] "/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/TestInvalid.xml"

$version
[1] "1.0"

$children
$children$doc
<doc>
 <title>
  <version/>
 </title>
</doc>


attr(,"class")
[1] "XMLDocumentContent"

$dtd
$external
NULL

$internal
$elements
$elements$doc
$name
[1] "doc"

$type
element 
     15 

$contents
$type
Sequence 
       3 

$ocur
Once 
   1 

$elements
$elements[[1]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "title"

attr(,"class")
[1] "XMLElementContent"

$elements[[2]]
$type
Element 
      2 

$ocur
Once 
   1 

$elements
[1] "version"

attr(,"class")
[1] "XMLElementContent"


attr(,"class")
[1] "XMLSequenceContent"

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$version
$name
[1] "version"

$type
empty 
   15 

$contents
NULL

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"

$elements$title
$name
[1] "title"

$type
empty 
   15 

$contents
NULL

$attributes
NULL

attr(,"class")
[1] "XMLElementDef"


$entities
NULL

attr(,"class")
[1] "InternalDTD"

attr(,"class")
[1] "DTDList"

attr(,"class")
[1] "XMLDocument"         "XMLAbstractDocument" "oldClass"           
> 
> ## Not run: 
> ##D  # Parse an XML document directly from a URL.
> ##D  # Requires Internet access.
> ##D  xmlTreeParse("http://www.omegahat.org/Scripts/Data/mtcars.xml", asText=TRUE)
> ## End(Not run)
> 
>   counter = function() {
+               counts = integer(0)
+               list(startElement = function(node) {
+                                      name = xmlName(node)
+                                      if(name %in% names(counts))
+                                           counts[name] <<- counts[name] + 1
+                                      else
+                                           counts[name] <<- 1
+                                   },
+                     counts = function() counts)
+             }
> 
>    h = counter()
>    xmlParse(system.file("exampleData", "mtcars.xml", package="XML"),  handlers = h)
$startElement
function (node) 
{
    name = xmlName(node)
    if (name %in% names(counts)) 
        counts[name] <<- counts[name] + 1
    else counts[name] <<- 1
}
<environment: 0x7fa8f350cb58>

$counts
function () 
counts
<environment: 0x7fa8f350cb58>

>    h$counts()
 variable variables    record   dataset 
       11         1        32         1 
> 
> 
> 
>  f = system.file("examples", "index.html", package = "XML")
>  htmlTreeParse(readLines(f), asText = TRUE)
$file
[1] "<buffer>"

$version
[1] ""

$children
$children$html
<html>
 <head>
  <title>XML Package for R and S-Plus</title>
 </head>
 <body>
  <h1>An XML package for the S language</h1>
  <p align="right">
   Source:
   <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  </p>
  <p align="right">
   Windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p align="right">
   Last Release:
   <font color="red">Thu Aug 12 07:56:21 PDT 2004</font>
  </p>
  <p>This package provides facilities for the S language
to</p>
  <ul>
   <li>parse XML files, URLs and strings,
      using either the DOM (Document Object Model)/tree-based
      approach, or the event-driven SAX (Simple API for XML)
      mechanism;</li>
   <li>generate XML content to buffers, files, URLs,
      and internal XML trees;</li>
   <li>read DTDs as S objects.</li>
  </ul>
  The package supports both R and S-Plus 5 and higher.
  <h2>
   <font color="red">NOTE</font>
  </h2>
  The most significant visible changes to the package include:
  <ul>
   <li>uses libxml2, by default and only libxml(version 1) if libxml2
      is not present</li>
   <li>uses a namespace for R.</li>
  </ul>
  <h2>Download</h2>
  The source for the S package can
be downloaded as
  <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  .
  <p>
   Latest windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p>
   Note that this latest version has not been tested with S-Plus
Specifically, it should work as before, however the
   <code>state</code>
   mechanism for the SAX parser may not.  This just requires testing.
  </p>
  <h2>Documentation</h2>
  <dl>
   <dt>
    <li>
     A reasonably detailed
     <a href="Overview.html">overview</a>
     of the package and what we might use XML for.
     <dd/>
     <dt>
      <li>
       A
       <a href="manual.pdf">manual</a>
       in 
    and a
       <a href="Tour.pdf">quick guide</a>
       to the package (PDF).
       <dd>b</dd>
       <dt>
        <li>
         A short
         <a href="description.pdf">overview</a>
         of the package.
         <dd/>
         <dt>
          <li>
           Brief and incomplete Notes on
           <a href="WritingXML.html">generating XML</a>
           within S
           <dd/>
           <dt>
            <li>
             <a href="FAQ.html">FAQ</a>
             for the package.
             <dd/>
             <dt>
              <li>
               <a href="Changes">Changes</a>
               to the packages (by release).
               <dd/>
              </li>
             </dt>
            </li>
           </dt>
          </li>
         </dt>
        </li>
       </dt>
      </li>
     </dt>
    </li>
   </dt>
  </dl>
  <hr/>
  <address>
   <a href="http://cm.bell-labs.com/stat/duncan">Duncan Temple Lang</a>
   <a href="mailto:duncan@wald.ucdavis.edu">&lt;duncan@wald.ucdavis.edu&gt;</a>
  </address>
  <!--hhmts start-->
  Last modified: Fri Apr  1 04:32:29 PST 2005
  <!--hhmts end-->
 </body>
</html>


attr(,"class")
[1] "HTMLDocument"
>  htmlTreeParse(readLines(f))
$file
[1] "<buffer>"

$version
[1] ""

$children
$children$html
<html>
 <head>
  <title>XML Package for R and S-Plus</title>
 </head>
 <body>
  <h1>An XML package for the S language</h1>
  <p align="right">
   Source:
   <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  </p>
  <p align="right">
   Windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p align="right">
   Last Release:
   <font color="red">Thu Aug 12 07:56:21 PDT 2004</font>
  </p>
  <p>This package provides facilities for the S language
to</p>
  <ul>
   <li>parse XML files, URLs and strings,
      using either the DOM (Document Object Model)/tree-based
      approach, or the event-driven SAX (Simple API for XML)
      mechanism;</li>
   <li>generate XML content to buffers, files, URLs,
      and internal XML trees;</li>
   <li>read DTDs as S objects.</li>
  </ul>
  The package supports both R and S-Plus 5 and higher.
  <h2>
   <font color="red">NOTE</font>
  </h2>
  The most significant visible changes to the package include:
  <ul>
   <li>uses libxml2, by default and only libxml(version 1) if libxml2
      is not present</li>
   <li>uses a namespace for R.</li>
  </ul>
  <h2>Download</h2>
  The source for the S package can
be downloaded as
  <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  .
  <p>
   Latest windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p>
   Note that this latest version has not been tested with S-Plus
Specifically, it should work as before, however the
   <code>state</code>
   mechanism for the SAX parser may not.  This just requires testing.
  </p>
  <h2>Documentation</h2>
  <dl>
   <dt>
    <li>
     A reasonably detailed
     <a href="Overview.html">overview</a>
     of the package and what we might use XML for.
     <dd/>
     <dt>
      <li>
       A
       <a href="manual.pdf">manual</a>
       in 
    and a
       <a href="Tour.pdf">quick guide</a>
       to the package (PDF).
       <dd>b</dd>
       <dt>
        <li>
         A short
         <a href="description.pdf">overview</a>
         of the package.
         <dd/>
         <dt>
          <li>
           Brief and incomplete Notes on
           <a href="WritingXML.html">generating XML</a>
           within S
           <dd/>
           <dt>
            <li>
             <a href="FAQ.html">FAQ</a>
             for the package.
             <dd/>
             <dt>
              <li>
               <a href="Changes">Changes</a>
               to the packages (by release).
               <dd/>
              </li>
             </dt>
            </li>
           </dt>
          </li>
         </dt>
        </li>
       </dt>
      </li>
     </dt>
    </li>
   </dt>
  </dl>
  <hr/>
  <address>
   <a href="http://cm.bell-labs.com/stat/duncan">Duncan Temple Lang</a>
   <a href="mailto:duncan@wald.ucdavis.edu">&lt;duncan@wald.ucdavis.edu&gt;</a>
  </address>
  <!--hhmts start-->
  Last modified: Fri Apr  1 04:32:29 PST 2005
  <!--hhmts end-->
 </body>
</html>


attr(,"class")
[1] "HTMLDocument"
> 
>   # Same as 
>  htmlTreeParse(paste(readLines(f), collapse = "\n"), asText = TRUE)
$file
[1] "<buffer>"

$version
[1] ""

$children
$children$html
<html>
 <head>
  <title>XML Package for R and S-Plus</title>
 </head>
 <body>
  <h1>An XML package for the S language</h1>
  <p align="right">
   Source:
   <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  </p>
  <p align="right">
   Windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p align="right">
   Last Release:
   <font color="red">Thu Aug 12 07:56:21 PDT 2004</font>
  </p>
  <p>This package provides facilities for the S language
to</p>
  <ul>
   <li>parse XML files, URLs and strings,
      using either the DOM (Document Object Model)/tree-based
      approach, or the event-driven SAX (Simple API for XML)
      mechanism;</li>
   <li>generate XML content to buffers, files, URLs,
      and internal XML trees;</li>
   <li>read DTDs as S objects.</li>
  </ul>
  The package supports both R and S-Plus 5 and higher.
  <h2>
   <font color="red">NOTE</font>
  </h2>
  The most significant visible changes to the package include:
  <ul>
   <li>uses libxml2, by default and only libxml(version 1) if libxml2
      is not present</li>
   <li>uses a namespace for R.</li>
  </ul>
  <h2>Download</h2>
  The source for the S package can
be downloaded as
  <a href="XML_0.97-0.tar.gz">XML_0.97-0.tar.gz</a>
  .
  <p>
   Latest windows binary:
   <a href="XML_0.97-0.zip">XML_0.97-0.zip</a>
  </p>
  <p>
   Note that this latest version has not been tested with S-Plus
Specifically, it should work as before, however the
   <code>state</code>
   mechanism for the SAX parser may not.  This just requires testing.
  </p>
  <h2>Documentation</h2>
  <dl>
   <dt>
    <li>
     A reasonably detailed
     <a href="Overview.html">overview</a>
     of the package and what we might use XML for.
     <dd/>
     <dt>
      <li>
       A
       <a href="manual.pdf">manual</a>
       in 
    and a
       <a href="Tour.pdf">quick guide</a>
       to the package (PDF).
       <dd>b</dd>
       <dt>
        <li>
         A short
         <a href="description.pdf">overview</a>
         of the package.
         <dd/>
         <dt>
          <li>
           Brief and incomplete Notes on
           <a href="WritingXML.html">generating XML</a>
           within S
           <dd/>
           <dt>
            <li>
             <a href="FAQ.html">FAQ</a>
             for the package.
             <dd/>
             <dt>
              <li>
               <a href="Changes">Changes</a>
               to the packages (by release).
               <dd/>
              </li>
             </dt>
            </li>
           </dt>
          </li>
         </dt>
        </li>
       </dt>
      </li>
     </dt>
    </li>
   </dt>
  </dl>
  <hr/>
  <address>
   <a href="http://cm.bell-labs.com/stat/duncan">Duncan Temple Lang</a>
   <a href="mailto:duncan@wald.ucdavis.edu">&lt;duncan@wald.ucdavis.edu&gt;</a>
  </address>
  <!--hhmts start-->
  Last modified: Fri Apr  1 04:32:29 PST 2005
  <!--hhmts end-->
 </body>
</html>


attr(,"class")
[1] "HTMLDocument"
> 
> 
>  getLinks = function() { 
+        links = character() 
+        list(a = function(node, ...) { 
+                    links <<- c(links, xmlGetAttr(node, "href"))
+                    node 
+                 }, 
+             links = function()links)
+      }
> 
>  h1 = getLinks()
>  htmlTreeParse(system.file("examples", "index.html", package = "XML"), handlers = h1)
$a
function (node, ...) 
{
    links <<- c(links, xmlGetAttr(node, "href"))
    node
}
<environment: 0x7fa8ed2abf18>

$links
function () 
links
<environment: 0x7fa8ed2abf18>

>  h1$links()
 [1] "XML_0.97-0.tar.gz"                   "XML_0.97-0.zip"                     
 [3] "XML_0.97-0.tar.gz"                   "XML_0.97-0.zip"                     
 [5] "Overview.html"                       "manual.pdf"                         
 [7] "Tour.pdf"                            "description.pdf"                    
 [9] "WritingXML.html"                     "FAQ.html"                           
[11] "Changes"                             "http://cm.bell-labs.com/stat/duncan"
[13] "mailto:duncan@wald.ucdavis.edu"     
> 
>  h2 = getLinks()
>  htmlTreeParse(system.file("examples", "index.html", package = "XML"), handlers = h2, useInternalNodes = TRUE)
$a
function (node, ...) 
{
    links <<- c(links, xmlGetAttr(node, "href"))
    node
}
<environment: 0x7fa8ed19ca60>

$links
function () 
links
<environment: 0x7fa8ed19ca60>

>  all(h1$links() == h2$links())
[1] TRUE
> 
>   # Using flat trees
>  tt = xmlHashTree()
>  f = system.file("exampleData", "mtcars.xml", package="XML")
>  xmlTreeParse(f, handlers = list(.startElement = tt[[".addNode"]]))
$.startElement
function (node, parent = character(), ..., attrs = NULL, namespace = NULL, 
    namespaceDefinitions = character(), .children = list(...), 
    cdata = FALSE, suppressNamespaceWarning = getOption("suppressXMLNamespaceWarning", 
        FALSE)) 
{
    if (is.character(node)) 
        node = xmlNode(node, attrs = attrs, namespace = namespace, 
            namespaceDefinitions = namespaceDefinitions)
    .kids = .children
    .children = .this$.children
    node = asXMLTreeNode(node, .this, className = "XMLHashTreeNode")
    id = node$id
    assign(id, node, env)
    .count <<- .count + 1
    if (!inherits(parent, "XMLNode") && (!is.environment(parent) && 
        length(parent) == 0) || parent == "") 
        return(node)
    if (inherits(parent, "XMLHashTreeNode")) 
        parent = parent$id
    if (length(parent)) {
        assign(id, parent, env = .parents)
        if (exists(parent, .children, inherits = FALSE)) 
            tmp = c(get(parent, .children), id)
        else tmp = id
        assign(parent, tmp, .children)
    }
    return(node)
}
<environment: 0x7fa8ed16bb18>

>  xmlRoot(tt)
<variable/>
> 
> 
> 
>  doc = xmlTreeParse(f, useInternalNodes = TRUE)
> 
>  sapply(getNodeSet(doc, "//variable"), xmlValue)
 [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
[11] "carb"
>          
>  #free(doc) 
> 
> 
>   # character set encoding for HTML
>  f = system.file("exampleData", "9003.html", package = "XML")
>    # we specify the encoding
>  d = htmlTreeParse(f, encoding = "UTF-8")
>    # get a different result if we do not specify any encoding
>  d.no = htmlTreeParse(f)
>    # document with its encoding in the HEAD of the document.
>  d.self = htmlTreeParse(system.file("exampleData", "9003-en.html",package = "XML"))
>    # XXX want to do a test here to see the similarities between d and
>    # d.self and differences between d.no
> 
> 
>   # include
>  f = system.file("exampleData", "nodes1.xml", package = "XML")
>  xmlRoot(xmlTreeParse(f, xinclude = FALSE))
<x xmlns:xinclude="http://www.w3.org/2001/XInclude">
 <!--Simple test of including a set of nodes from an XML document-->
 <xinclude:include href="something.xml#xpointer(//p)"/>
</x>
>  xmlRoot(xmlTreeParse(f, xinclude = TRUE))
<x xmlns:xinclude="http://www.w3.org/2001/XInclude">
 <!--Simple test of including a set of nodes from an XML document-->
 <p ID="author">something</p>
 <p>really</p>
 <p>simple</p>
</x>
> 
>  f = system.file("exampleData", "nodes2.xml", package = "XML")
>  xmlRoot(xmlTreeParse(f, xinclude = TRUE))
failed to load external entity "/Users/duncan/Projects/org/omegahat/XML/RS/XML.Rcheck/XML/exampleData/doesnt_exist.xml"
<x xmlns:xinclude="http://www.w3.org/2001/XInclude">
 <!--Simple test of including a set of nodes from an XML document-->
 Some
 <i>fallback text</i>
</x>
> 
>   # Errors
>   try(xmlTreeParse("<doc><a> & < <?pi > </doc>"))
xmlParseEntityRef: no name
StartTag: invalid element name
ParsePI: PI pi never end ...
Premature end of data in tag a line 1
Premature end of data in tag doc line 1
Error : 1: xmlParseEntityRef: no name
2: StartTag: invalid element name
3: ParsePI: PI pi never end ...
4: Premature end of data in tag a line 1
5: Premature end of data in tag doc line 1

> 
>     # catch the error by type.
>  tryCatch(xmlTreeParse("<doc><a> & < <?pi > </doc>"),
+                 "XMLParserErrorList" = function(e) {
+                                                       cat("Errors in XML document\n", e$message, "\n")
+                                                     })
xmlParseEntityRef: no name
StartTag: invalid element name
ParsePI: PI pi never end ...
Premature end of data in tag a line 1
Premature end of data in tag doc line 1
Errors in XML document
 1: xmlParseEntityRef: no name
2: StartTag: invalid element name
3: ParsePI: PI pi never end ...
4: Premature end of data in tag a line 1
5: Premature end of data in tag doc line 1
 
> 
>     #  terminate on first error            
>   try(xmlTreeParse("<doc><a> & < <?pi > </doc>", error = NULL))
Error : xmlParseEntityRef: no name

> 
>     #  see xmlErrorCumulator in the XML package 
> 
> 
>   f = system.file("exampleData", "book.xml", package = "XML")
>   doc.trim = xmlInternalTreeParse(f, trim = TRUE)
>   doc = xmlInternalTreeParse(f, trim = FALSE)
>   xmlSApply(xmlRoot(doc.trim), class)
     chapter                  chapter                 
[1,] "XMLInternalElementNode" "XMLInternalElementNode"
[2,] "XMLInternalNode"        "XMLInternalNode"       
[3,] "XMLAbstractNode"        "XMLAbstractNode"       
>       # note the additional XMLInternalTextNode objects
>   xmlSApply(xmlRoot(doc), class)
     text                  chapter                  text                 
[1,] "XMLInternalTextNode" "XMLInternalElementNode" "XMLInternalTextNode"
[2,] "XMLInternalNode"     "XMLInternalNode"        "XMLInternalNode"    
[3,] "XMLAbstractNode"     "XMLAbstractNode"        "XMLAbstractNode"    
     chapter                  text                 
[1,] "XMLInternalElementNode" "XMLInternalTextNode"
[2,] "XMLInternalNode"        "XMLInternalNode"    
[3,] "XMLAbstractNode"        "XMLAbstractNode"    
> 
> 
>   top = xmlRoot(doc)
>   textNodes = xmlSApply(top, inherits, "XMLInternalTextNode")
>   sapply(xmlChildren(top)[textNodes], xmlValue)
 text  text  text 
"\n " "\n "  "\n" 
> 
> 
>      # Storing nodes
>    f = system.file("exampleData", "book.xml", package = "XML")
>    titles = list()
>    xmlTreeParse(f, handlers = list(title = function(x)
+                                   titles[[length(titles) + 1]] <<- x))
$title
function (x) 
titles[[length(titles) + 1]] <<- x

>    sapply(titles, xmlValue)
[1] "XML"                             "The elements of an XML document"
[3] "Parsing XML"                     "DOM"                            
[5] "SAX"                             "XSL"                            
[7] "templates"                       "XPath expressions"              
[9] "named templates"                
>    rm(titles)
> 
> 
> 
> cleanEx()
> nameEx("xmlValue")
> ### * xmlValue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xmlValue
> ### Title: Extract or set the contents of a leaf XML node
> ### Aliases: xmlValue xmlValue.XMLCDataNode xmlValue.XMLNode
> ###   xmlValue.XMLProcessingInstruction xmlValue.XMLTextNode
> ###   xmlValue.XMLComment xmlValue<- xmlValue<-,XMLAbstractNode-method
> ###   xmlValue<-,XMLInternalTextNode-method xmlValue<-,XMLTextNode-method
> ###   coerce,XMLInternalTextNode,character-method
> ### Keywords: file
> 
> ### ** Examples
> 
>  node <- xmlNode("foo", "Some text")
>  xmlValue(node)
[1] "Some text"
> 
>  xmlValue(xmlTextNode("some more raw text"))
[1] "some more raw text"
> 
>   # Setting the xmlValue().
>  a = newXMLNode("a")
>  xmlValue(a) = "the text"
>  xmlValue(a) = "different text"
> 
>  a = newXMLNode("x", "bob")
>  xmlValue(a) = "joe"
> 
>  b = xmlNode("bob")
>  xmlValue(b) = "Foo"
>  xmlValue(b) = "again"
> 
>  b = newXMLNode("bob", "some text")
>  xmlValue(b[[1]]) = "change"
>  b
<bob>change</bob> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cat("Time elapsed: ", proc.time() - get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  30.984 0.634 81.575 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
